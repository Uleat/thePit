 common/CMakeLists.txt      |   4 +
 common/Item.cpp            | 257 +++++++++++---------------
 common/Item.h              | 443 +++++++++++++++++++++++++++++++++++++++++----
 common/clientversions.h    |  27 +--
 common/eq_constants.h      | 253 +++++++++++++++++---------
 common/eq_packet_structs.h |  37 ++++
 common/patches/RoF.cpp     |   2 +-
 common/shareddb.cpp        |  18 +-
 zone/MobAI.cpp             |   2 +-
 zone/Object.cpp            |  10 +-
 zone/attack.cpp            |  16 +-
 zone/bonuses.cpp           |   2 +-
 zone/bot.cpp               | 230 +++++++++++------------
 zone/client.cpp            |  92 +++++-----
 zone/client.h              |   2 +-
 zone/client_mods.cpp       |   2 +-
 zone/client_packet.cpp     |  36 ++--
 zone/client_process.cpp    |  12 +-
 zone/command.cpp           |  40 ++--
 zone/corpse.cpp            |  12 +-
 zone/doors.cpp             |   6 +-
 zone/forage.cpp            |  16 +-
 zone/inventory.cpp         | 132 +++++++-------
 zone/loottables.cpp        |  22 +--
 zone/lua_general.cpp       |  56 +++---
 zone/merc.cpp              |  22 +--
 zone/merc.h                |   4 +-
 zone/mob.cpp               |  16 +-
 zone/npc.cpp               |   2 +-
 zone/npc.h                 |   2 +-
 zone/pets.cpp              |  10 +-
 zone/special_attacks.cpp   |  72 ++++----
 zone/spell_effects.cpp     |   8 +-
 zone/titles.cpp            |   2 +-
 zone/tradeskills.cpp       |  10 +-
 zone/trading.cpp           |  32 ++--
 zone/zonedb.cpp            |   8 +-
 zone/zonedb.h              |   2 +-
 38 files changed, 1180 insertions(+), 739 deletions(-)

diff --git a/common/CMakeLists.txt b/common/CMakeLists.txt
index a635639..444d600 100644
--- a/common/CMakeLists.txt
+++ b/common/CMakeLists.txt
@@ -14,6 +14,7 @@ SET(common_sources
 	emu_opcodes.cpp
 	EmuTCPConnection.cpp
 	EmuTCPServer.cpp
+	eq_limits.cpp
 	EQDB.cpp
 	EQDBRes.cpp
 	eqemu_exception.cpp
@@ -31,6 +32,7 @@ SET(common_sources
 	guilds.cpp
 	ipc_mutex.cpp
 	Item.cpp
+	item_.cpp
 	logsys.cpp
 	logsys_eqemu.cpp
 	md5.cpp
@@ -109,6 +111,7 @@ SET(common_headers
 	EmuTCPConnection.h
 	EmuTCPServer.h
 	eq_constants.h
+	eq_limits.h
 	eq_packet_structs.h
 	EQDB.h
 	EQDBRes.h
@@ -135,6 +138,7 @@ SET(common_headers
 	guilds.h
 	ipc_mutex.h
 	Item.h
+	item_.h
 	item_fieldlist.h
 	item_struct.h
 	languages.h
diff --git a/common/Item.cpp b/common/Item.cpp
index 2e43a6d..ef54768 100644
--- a/common/Item.cpp
+++ b/common/Item.cpp
@@ -534,7 +534,7 @@ ItemInst* Inventory::GetItem(int16 slot_id) const
 	ItemInst* result = nullptr;
 
 	// Cursor
-	if (slot_id == SLOT_CURSOR) {
+	if (slot_id == Legacy::SLOT_CURSOR) {
 		// Cursor slot
 		result = m_cursor.peek_front();
 	}
@@ -564,37 +564,37 @@ ItemInst* Inventory::GetItem(int16 slot_id) const
 	// Inner bag slots
 	else if (slot_id>=3031 && slot_id<=3110) {
 		// Trade bag slots
-		ItemInst* inst = _GetItem(m_trade, Inventory::CalcSlotId(slot_id));
+		ItemInst* inst = _GetItem(m_trade, Legacy::CalcSlotId(slot_id));
 		if (inst && inst->IsType(ItemClassContainer)) {
-			result = inst->GetItem(Inventory::CalcBagIdx(slot_id));
+			result = inst->GetItem(Legacy::CalcBagIdx(slot_id));
 		}
 	}
 	else if (slot_id>=2531 && slot_id<=2550) {
 		// Shared Bank bag slots
-		ItemInst* inst = _GetItem(m_shbank, Inventory::CalcSlotId(slot_id));
+		ItemInst* inst = _GetItem(m_shbank, Legacy::CalcSlotId(slot_id));
 		if (inst && inst->IsType(ItemClassContainer)) {
-			result = inst->GetItem(Inventory::CalcBagIdx(slot_id));
+			result = inst->GetItem(Legacy::CalcBagIdx(slot_id));
 		}
 	}
 	else if (slot_id>=2031 && slot_id<=2270) {
 		// Bank bag slots
-		ItemInst* inst = _GetItem(m_bank, Inventory::CalcSlotId(slot_id));
+		ItemInst* inst = _GetItem(m_bank, Legacy::CalcSlotId(slot_id));
 		if (inst && inst->IsType(ItemClassContainer)) {
-			result = inst->GetItem(Inventory::CalcBagIdx(slot_id));
+			result = inst->GetItem(Legacy::CalcBagIdx(slot_id));
 		}
 	}
 	else if (slot_id>=331 && slot_id<=340) {
 		// Cursor bag slots
 		ItemInst* inst = m_cursor.peek_front();
 		if (inst && inst->IsType(ItemClassContainer)) {
-			result = inst->GetItem(Inventory::CalcBagIdx(slot_id));
+			result = inst->GetItem(Legacy::CalcBagIdx(slot_id));
 		}
 	}
 	else if (slot_id>=251 && slot_id<=330) {
 		// Personal inventory bag slots
-		ItemInst* inst = _GetItem(m_inv, Inventory::CalcSlotId(slot_id));
+		ItemInst* inst = _GetItem(m_inv, Legacy::CalcSlotId(slot_id));
 		if (inst && inst->IsType(ItemClassContainer)) {
-			result = inst->GetItem(Inventory::CalcBagIdx(slot_id));
+			result = inst->GetItem(Legacy::CalcBagIdx(slot_id));
 		}
 	}
 
@@ -812,13 +812,13 @@ uint32 ItemInst::GetKillsNeeded(uint8 currentlevel) {
 // Retrieve item at specified position within bag
 ItemInst* Inventory::GetItem(int16 slot_id, uint8 bagidx) const
 {
-	return GetItem(Inventory::CalcSlotId(slot_id, bagidx));
+	return GetItem(Legacy::CalcSlotId(slot_id, bagidx));
 }
 
 int16 Inventory::PushCursor(const ItemInst& inst)
 {
 	m_cursor.push(inst.Clone());
-	return SLOT_CURSOR;
+	return Legacy::SLOT_CURSOR;
 }
 
 // Put an item snto specified slot
@@ -861,7 +861,7 @@ bool Inventory::SwapItem(int16 slot_a, int16 slot_b)
 
 int16 Inventory::HasItem(uint32 item_id, uint8 quantity, uint8 where)
 {
-	int16 slot_id = SLOT_INVALID;
+	int16 slot_id = Legacy::SLOT_INVALID;
 
 	//Altered by Father Nitwit to support a specification of
 	//where to search, with a default value to maintain compatibility
@@ -869,38 +869,38 @@ int16 Inventory::HasItem(uint32 item_id, uint8 quantity, uint8 where)
 	// Check each inventory bucket
 	if(where & invWhereWorn) {
 		slot_id = _HasItem(m_worn, item_id, quantity);
-		if (slot_id != SLOT_INVALID)
+		if (slot_id != Legacy::SLOT_INVALID)
 			return slot_id;
 	}
 
 	if(where & invWherePersonal) {
 		slot_id = _HasItem(m_inv, item_id, quantity);
-		if (slot_id != SLOT_INVALID)
+		if (slot_id != Legacy::SLOT_INVALID)
 			return slot_id;
 	}
 
 	if(where & invWhereBank) {
 		slot_id = _HasItem(m_bank, item_id, quantity);
-		if (slot_id != SLOT_INVALID)
+		if (slot_id != Legacy::SLOT_INVALID)
 			return slot_id;
 	}
 
 	if(where & invWhereSharedBank) {
 		slot_id = _HasItem(m_shbank, item_id, quantity);
-		if (slot_id != SLOT_INVALID)
+		if (slot_id != Legacy::SLOT_INVALID)
 			return slot_id;
 	}
 
 	if(where & invWhereTrading) {
 		slot_id = _HasItem(m_trade, item_id, quantity);
-		if (slot_id != SLOT_INVALID)
+		if (slot_id != Legacy::SLOT_INVALID)
 			return slot_id;
 	}
 
 	if(where & invWhereCursor) {
 		// Check cursor queue
 		slot_id = _HasItem(m_cursor, item_id, quantity);
-		if (slot_id != SLOT_INVALID)
+		if (slot_id != Legacy::SLOT_INVALID)
 			return slot_id;
 	}
 
@@ -911,43 +911,43 @@ int16 Inventory::HasItem(uint32 item_id, uint8 quantity, uint8 where)
 
 int16 Inventory::HasItemByUse(uint8 use, uint8 quantity, uint8 where)
 {
-	int16 slot_id = SLOT_INVALID;
+	int16 slot_id = Legacy::SLOT_INVALID;
 
 	// Check each inventory bucket
 	if(where & invWhereWorn) {
 		slot_id = _HasItemByUse(m_worn, use, quantity);
-		if (slot_id != SLOT_INVALID)
+		if (slot_id != Legacy::SLOT_INVALID)
 			return slot_id;
 	}
 
 	if(where & invWherePersonal) {
 		slot_id = _HasItemByUse(m_inv, use, quantity);
-		if (slot_id != SLOT_INVALID)
+		if (slot_id != Legacy::SLOT_INVALID)
 			return slot_id;
 	}
 
 	if(where & invWhereBank) {
 		slot_id = _HasItemByUse(m_bank, use, quantity);
-		if (slot_id != SLOT_INVALID)
+		if (slot_id != Legacy::SLOT_INVALID)
 			return slot_id;
 	}
 
 	if(where & invWhereSharedBank) {
 		slot_id = _HasItemByUse(m_shbank, use, quantity);
-		if (slot_id != SLOT_INVALID)
+		if (slot_id != Legacy::SLOT_INVALID)
 			return slot_id;
 	}
 
 	if(where & invWhereTrading) {
 		slot_id = _HasItemByUse(m_trade, use, quantity);
-		if (slot_id != SLOT_INVALID)
+		if (slot_id != Legacy::SLOT_INVALID)
 			return slot_id;
 	}
 
 	if(where & invWhereCursor) {
 		// Check cursor queue
 		slot_id = _HasItemByUse(m_cursor, use, quantity);
-		if (slot_id != SLOT_INVALID)
+		if (slot_id != Legacy::SLOT_INVALID)
 			return slot_id;
 	}
 
@@ -956,43 +956,43 @@ int16 Inventory::HasItemByUse(uint8 use, uint8 quantity, uint8 where)
 
 int16 Inventory::HasItemByLoreGroup(uint32 loregroup, uint8 where)
 {
-	int16 slot_id = SLOT_INVALID;
+	int16 slot_id = Legacy::SLOT_INVALID;
 
 	// Check each inventory bucket
 	if(where & invWhereWorn) {
 		slot_id = _HasItemByLoreGroup(m_worn, loregroup);
-		if (slot_id != SLOT_INVALID)
+		if (slot_id != Legacy::SLOT_INVALID)
 			return slot_id;
 	}
 
 	if(where & invWherePersonal) {
 		slot_id = _HasItemByLoreGroup(m_inv, loregroup);
-		if (slot_id != SLOT_INVALID)
+		if (slot_id != Legacy::SLOT_INVALID)
 			return slot_id;
 	}
 
 	if(where & invWhereBank) {
 		slot_id = _HasItemByLoreGroup(m_bank, loregroup);
-		if (slot_id != SLOT_INVALID)
+		if (slot_id != Legacy::SLOT_INVALID)
 			return slot_id;
 	}
 
 	if(where & invWhereSharedBank) {
 		slot_id = _HasItemByLoreGroup(m_shbank, loregroup);
-		if (slot_id != SLOT_INVALID)
+		if (slot_id != Legacy::SLOT_INVALID)
 			return slot_id;
 	}
 
 	if(where & invWhereTrading) {
 		slot_id = _HasItemByLoreGroup(m_trade, loregroup);
-		if (slot_id != SLOT_INVALID)
+		if (slot_id != Legacy::SLOT_INVALID)
 			return slot_id;
 	}
 
 	if(where & invWhereCursor) {
 		// Check cursor queue
 		slot_id = _HasItemByLoreGroup(m_cursor, loregroup);
-		if (slot_id != SLOT_INVALID)
+		if (slot_id != Legacy::SLOT_INVALID)
 			return slot_id;
 	}
 
@@ -1019,7 +1019,7 @@ bool Inventory::HasSpaceForItem(const Item_Struct *ItemToTry, int16 Quantity) {
 			}
 			if (InvItem && InvItem->IsType(ItemClassContainer)) {
 
-				int16 BaseSlotID = Inventory::CalcSlotId(i, 0);
+				int16 BaseSlotID = Legacy::CalcSlotId(i, 0);
 				uint8 BagSize=InvItem->GetItem()->BagSlots;
 				for (uint8 BagSlot = 0; BagSlot < BagSize; BagSlot++) {
 
@@ -1063,7 +1063,7 @@ bool Inventory::HasSpaceForItem(const Item_Struct *ItemToTry, int16 Quantity) {
 		}
 		else if(InvItem->IsType(ItemClassContainer) && CanItemFitInContainer(ItemToTry, InvItem->GetItem())) {
 
-			int16 BaseSlotID = Inventory::CalcSlotId(i, 0);
+			int16 BaseSlotID = Legacy::CalcSlotId(i, 0);
 
 			uint8 BagSize=InvItem->GetItem()->BagSlots;
 
@@ -1136,7 +1136,7 @@ bool Inventory::CheckNoDrop(int16 slot_id) {
 	if (!inst->GetItem()->NoDrop) return true;
 	if (inst->GetItem()->ItemClass == 1) {
 		for (uint8 i = 0; i < 10; i++) {
-			ItemInst* bagitem = GetItem(Inventory::CalcSlotId(slot_id, i));
+			ItemInst* bagitem = GetItem(Legacy::CalcSlotId(slot_id, i));
 			if (bagitem && !bagitem->GetItem()->NoDrop) return true;
 		}
 	}
@@ -1149,7 +1149,7 @@ ItemInst* Inventory::PopItem(int16 slot_id)
 {
 	ItemInst* p = nullptr;
 
-	if (slot_id==SLOT_CURSOR) { // Cursor
+	if (slot_id==Legacy::SLOT_CURSOR) { // Cursor
 		p = m_cursor.pop();
 	}
 	else if ((slot_id>=0 && slot_id<=21) || (slot_id >= 400 && slot_id<=404) || (slot_id == 9999)) { // Worn slots
@@ -1174,9 +1174,9 @@ ItemInst* Inventory::PopItem(int16 slot_id)
 	}
 	else {
 		// Is slot inside bag?
-		ItemInst* baginst = GetItem(Inventory::CalcSlotId(slot_id));
+		ItemInst* baginst = GetItem(Legacy::CalcSlotId(slot_id));
 		if (baginst != nullptr && baginst->IsType(ItemClassContainer)) {
-			p = baginst->PopItem(Inventory::CalcBagIdx(slot_id));
+			p = baginst->PopItem(Legacy::CalcBagIdx(slot_id));
 		}
 	}
 
@@ -1206,7 +1206,7 @@ int16 Inventory::FindFreeSlot(bool for_bag, bool try_cursor, uint8 min_size, boo
 					continue;
 				}
 
-				int16 base_slot_id = Inventory::CalcSlotId(i, 0);
+				int16 base_slot_id = Legacy::CalcSlotId(i, 0);
 
 				uint8 slots=inst->GetItem()->BagSlots;
 				uint8 j;
@@ -1222,10 +1222,10 @@ int16 Inventory::FindFreeSlot(bool for_bag, bool try_cursor, uint8 min_size, boo
 	if (try_cursor)
 		// Always room on cursor (it's a queue)
 		// (we may wish to cap this in the future)
-		return SLOT_CURSOR;
+		return Legacy::SLOT_CURSOR;
 
 	// No available slots
-	return SLOT_INVALID;
+	return Legacy::SLOT_INVALID;
 }
 
 void Inventory::dumpBagContents(ItemInst *inst, iter_inst *it) {
@@ -1241,7 +1241,7 @@ void Inventory::dumpBagContents(ItemInst *inst, iter_inst *it) {
 			continue;
 
 		std::string subSlot;
-		StringFormat(subSlot,"	Slot %d: %s (%d)", Inventory::CalcSlotId((*it)->first, itb->first),
+		StringFormat(subSlot,"	Slot %d: %s (%d)", Legacy::CalcSlotId((*it)->first, itb->first),
 			baginst->GetItem()->Name, (baginst->GetCharges()<=0) ? 1 : baginst->GetCharges());
 		std::cout << subSlot << std::endl;
 	}
@@ -1278,7 +1278,7 @@ int Inventory::GetSlotByItemInst(ItemInst *inst) {
 	}
 
 	if(m_cursor.peek_front() == inst) {
-		return SLOT_CURSOR;
+		return Legacy::SLOT_CURSOR;
 	}
 
 	return -1;
@@ -1294,7 +1294,7 @@ int Inventory::GetSlotByItemInstCollection(const std::map<int16, ItemInst*> &col
 		if(t_inst && !t_inst->IsType(ItemClassContainer)) {
 			for(auto b_iter = t_inst->_begin(); b_iter != t_inst->_end(); ++b_iter) {
 				if(b_iter->second == inst) {
-					return Inventory::CalcSlotId(iter->first, b_iter->first);
+					return Legacy::CalcSlotId(iter->first, b_iter->first);
 				}
 			}
 		}
@@ -1376,9 +1376,9 @@ int16 Inventory::_PutItem(int16 slot_id, ItemInst* inst)
 		return slot_id;
 	}
 
-	int16 result = SLOT_INVALID;
+	int16 result = Legacy::SLOT_INVALID;
 
-	if (slot_id==SLOT_CURSOR) { // Cursor
+	if (slot_id==Legacy::SLOT_CURSOR) { // Cursor
 		// Replace current item on cursor, if exists
 		m_cursor.pop(); // no memory delete, clients of this function know what they are doing
 		m_cursor.push_front(inst);
@@ -1406,14 +1406,14 @@ int16 Inventory::_PutItem(int16 slot_id, ItemInst* inst)
 	}
 	else {
 		// Slot must be within a bag
-		ItemInst* baginst = GetItem(Inventory::CalcSlotId(slot_id)); // Get parent bag
+		ItemInst* baginst = GetItem(Legacy::CalcSlotId(slot_id)); // Get parent bag
 		if (baginst && baginst->IsType(ItemClassContainer)) {
-			baginst->_PutItem(Inventory::CalcBagIdx(slot_id), inst);
+			baginst->_PutItem(Legacy::CalcBagIdx(slot_id), inst);
 			result = slot_id;
 		}
 	}
 
-	if (result == SLOT_INVALID) {
+	if (result == Legacy::SLOT_INVALID) {
 		LogFile->write(EQEMuLog::Error, "Inventory::_PutItem: Invalid slot_id specified (%i)", slot_id);
 		Inventory::MarkDirty(inst); // Slot not found, clean up
 	}
@@ -1441,7 +1441,7 @@ int16 Inventory::_HasItem(std::map<int16, ItemInst*>& bucket, uint32 item_id, ui
 
 			for(int i = 0; i < MAX_AUGMENT_SLOTS; i++) {
 				if (inst->GetAugmentItemID(i) == item_id && quantity <= 1)
-					return SLOT_AUGMENT; // Only one augment per slot.
+					return Legacy::SLOT_AUGMENT; // Only one augment per slot.
 			}
 		}
 		// Go through bag, if bag
@@ -1452,18 +1452,18 @@ int16 Inventory::_HasItem(std::map<int16, ItemInst*>& bucket, uint32 item_id, ui
 				if (baginst->GetID() == item_id) {
 					quantity_found += (baginst->GetCharges()<=0) ? 1 : baginst->GetCharges();
 					if (quantity_found >= quantity)
-						return Inventory::CalcSlotId(it->first, itb->first);
+						return Legacy::CalcSlotId(it->first, itb->first);
 				}
 				for(int i = 0; i < MAX_AUGMENT_SLOTS; i++) {
 					if (baginst->GetAugmentItemID(i) == item_id && quantity <= 1)
-						return SLOT_AUGMENT; // Only one augment per slot.
+						return Legacy::SLOT_AUGMENT; // Only one augment per slot.
 				}
 			}
 		}
 	}
 
 	// Not found
-	return SLOT_INVALID;
+	return Legacy::SLOT_INVALID;
 }
 
 // Internal Method: Checks an inventory queue type bucket for a particular item
@@ -1481,11 +1481,11 @@ int16 Inventory::_HasItem(ItemInstQueue& iqueue, uint32 item_id, uint8 quantity)
 			if (inst->GetID() == item_id) {
 				quantity_found += (inst->GetCharges()<=0) ? 1 : inst->GetCharges();
 				if (quantity_found >= quantity)
-					return SLOT_CURSOR;
+					return Legacy::SLOT_CURSOR;
 			}
 			for(int i = 0; i < MAX_AUGMENT_SLOTS; i++) {
 				if (inst->GetAugmentItemID(i) == item_id && quantity <= 1)
-					return SLOT_AUGMENT; // Only one augment per slot.
+					return Legacy::SLOT_AUGMENT; // Only one augment per slot.
 			}
 		}
 		// Go through bag, if bag
@@ -1496,11 +1496,11 @@ int16 Inventory::_HasItem(ItemInstQueue& iqueue, uint32 item_id, uint8 quantity)
 				if (baginst->GetID() == item_id) {
 					quantity_found += (baginst->GetCharges()<=0) ? 1 : baginst->GetCharges();
 					if (quantity_found >= quantity)
-						return Inventory::CalcSlotId(SLOT_CURSOR, itb->first);
+						return Legacy::CalcSlotId(Legacy::SLOT_CURSOR, itb->first);
 				}
 				for(int i = 0; i < MAX_AUGMENT_SLOTS; i++) {
 					if (baginst->GetAugmentItemID(i) == item_id && quantity <= 1)
-						return SLOT_AUGMENT; // Only one augment per slot.
+						return Legacy::SLOT_AUGMENT; // Only one augment per slot.
 				}
 
 			}
@@ -1508,7 +1508,7 @@ int16 Inventory::_HasItem(ItemInstQueue& iqueue, uint32 item_id, uint8 quantity)
 	}
 
 	// Not found
-	return SLOT_INVALID;
+	return Legacy::SLOT_INVALID;
 }
 
 // Internal Method: Checks an inventory bucket for a particular item
@@ -1536,14 +1536,14 @@ int16 Inventory::_HasItemByUse(std::map<int16, ItemInst*>& bucket, uint8 use, ui
 				if (baginst && baginst->IsType(ItemClassCommon) && baginst->GetItem()->ItemType == use) {
 					quantity_found += (baginst->GetCharges()<=0) ? 1 : baginst->GetCharges();
 					if (quantity_found >= quantity)
-						return Inventory::CalcSlotId(it->first, itb->first);
+						return Legacy::CalcSlotId(it->first, itb->first);
 				}
 			}
 		}
 	}
 
 	// Not found
-	return SLOT_INVALID;
+	return Legacy::SLOT_INVALID;
 }
 
 // Internal Method: Checks an inventory queue type bucket for a particular item
@@ -1559,7 +1559,7 @@ int16 Inventory::_HasItemByUse(ItemInstQueue& iqueue, uint8 use, uint8 quantity)
 		if (inst && inst->IsType(ItemClassCommon) && inst->GetItem()->ItemType == use) {
 			quantity_found += (inst->GetCharges()<=0) ? 1 : inst->GetCharges();
 			if (quantity_found >= quantity)
-				return SLOT_CURSOR;
+				return Legacy::SLOT_CURSOR;
 		}
 
 		// Go through bag, if bag
@@ -1570,14 +1570,14 @@ int16 Inventory::_HasItemByUse(ItemInstQueue& iqueue, uint8 use, uint8 quantity)
 				if (baginst && baginst->IsType(ItemClassCommon) && baginst->GetItem()->ItemType == use) {
 					quantity_found += (baginst->GetCharges()<=0) ? 1 : baginst->GetCharges();
 					if (quantity_found >= quantity)
-						return Inventory::CalcSlotId(SLOT_CURSOR, itb->first);
+						return Legacy::CalcSlotId(Legacy::SLOT_CURSOR, itb->first);
 				}
 			}
 		}
 	}
 
 	// Not found
-	return SLOT_INVALID;
+	return Legacy::SLOT_INVALID;
 }
 
 int16 Inventory::_HasItemByLoreGroup(std::map<int16, ItemInst*>& bucket, uint32 loregroup)
@@ -1597,7 +1597,7 @@ int16 Inventory::_HasItemByLoreGroup(std::map<int16, ItemInst*>& bucket, uint32
 			for(int i = 0; i < MAX_AUGMENT_SLOTS; i++) {
 				Aug = inst->GetAugment(i);
 				if (Aug && Aug->GetItem()->LoreGroup == loregroup)
-					return SLOT_AUGMENT; // Only one augment per slot.
+					return Legacy::SLOT_AUGMENT; // Only one augment per slot.
 			}
 		}
 		// Go through bag, if bag
@@ -1606,20 +1606,20 @@ int16 Inventory::_HasItemByLoreGroup(std::map<int16, ItemInst*>& bucket, uint32
 			for (itb=inst->_begin(); itb!=inst->_end(); ++itb) {
 				ItemInst* baginst = itb->second;
 				if (baginst && baginst->IsType(ItemClassCommon)&& baginst->GetItem()->LoreGroup == loregroup)
-					return Inventory::CalcSlotId(it->first, itb->first);
+					return Legacy::CalcSlotId(it->first, itb->first);
 
 				ItemInst* Aug2;
 				for(int i = 0; i < MAX_AUGMENT_SLOTS; i++) {
 					Aug2 = baginst->GetAugment(i);
 					if (Aug2 && Aug2->GetItem()->LoreGroup == loregroup)
-						return SLOT_AUGMENT; // Only one augment per slot.
+						return Legacy::SLOT_AUGMENT; // Only one augment per slot.
 				}
 			}
 		}
 	}
 
 	// Not found
-	return SLOT_INVALID;
+	return Legacy::SLOT_INVALID;
 }
 
 // Internal Method: Checks an inventory queue type bucket for a particular item
@@ -1634,13 +1634,13 @@ int16 Inventory::_HasItemByLoreGroup(ItemInstQueue& iqueue, uint32 loregroup)
 		if (inst)
 		{
 			if (inst->GetItem()->LoreGroup == loregroup)
-				return SLOT_CURSOR;
+				return Legacy::SLOT_CURSOR;
 
 			ItemInst* Aug;
 			for(int i = 0; i < MAX_AUGMENT_SLOTS; i++) {
 				Aug = inst->GetAugment(i);
 				if (Aug && Aug->GetItem()->LoreGroup == loregroup)
-					return SLOT_AUGMENT; // Only one augment per slot.
+					return Legacy::SLOT_AUGMENT; // Only one augment per slot.
 			}
 		}
 		// Go through bag, if bag
@@ -1649,14 +1649,14 @@ int16 Inventory::_HasItemByLoreGroup(ItemInstQueue& iqueue, uint32 loregroup)
 			for (itb=inst->_begin(); itb!=inst->_end(); ++itb) {
 				ItemInst* baginst = itb->second;
 				if (baginst && baginst->IsType(ItemClassCommon)&& baginst->GetItem()->LoreGroup == loregroup)
-					return Inventory::CalcSlotId(SLOT_CURSOR, itb->first);
+					return Legacy::CalcSlotId(Legacy::SLOT_CURSOR, itb->first);
 
 
 				ItemInst* Aug2;
 				for(int i = 0; i < MAX_AUGMENT_SLOTS; i++) {
 					Aug2 = baginst->GetAugment(i);
 					if (Aug2 && Aug2->GetItem()->LoreGroup == loregroup)
-						return SLOT_AUGMENT; // Only one augment per slot.
+						return Legacy::SLOT_AUGMENT; // Only one augment per slot.
 				}
 
 			}
@@ -1664,7 +1664,7 @@ int16 Inventory::_HasItemByLoreGroup(ItemInstQueue& iqueue, uint32 loregroup)
 	}
 
 	// Not found
-	return SLOT_INVALID;
+	return Legacy::SLOT_INVALID;
 }
 
 bool ItemInst::IsSlotAllowed(int16 slot_id) const {
@@ -1720,96 +1720,45 @@ bool ItemInst::IsAugmented()
 	return false;
 }
 
-// Calculate slot_id for an item within a bag
-int16 Inventory::CalcSlotId(int16 bagslot_id, uint8 bagidx)
-{
-	if (!Inventory::SupportsContainers(bagslot_id)) {
-		return SLOT_INVALID;
-	}
-
-	int16 slot_id = SLOT_INVALID;
-
-	if (bagslot_id==SLOT_CURSOR || bagslot_id==8000) // Cursor
-		slot_id = IDX_CURSOR_BAG + bagidx;
-	else if (bagslot_id>=22 && bagslot_id<=29) // Inventory slots
-		slot_id = IDX_INV_BAG + (bagslot_id-22)*MAX_ITEMS_PER_BAG + bagidx;
-	else if (bagslot_id>=2000 && bagslot_id<=2023) // Bank slots
-		slot_id = IDX_BANK_BAG + (bagslot_id-2000)*MAX_ITEMS_PER_BAG + bagidx;
-	else if (bagslot_id>=2500 && bagslot_id<=2501) // Shared bank slots
-		slot_id = IDX_SHBANK_BAG + (bagslot_id-2500)*MAX_ITEMS_PER_BAG + bagidx;
-	else if (bagslot_id>=3000 && bagslot_id<=3007) // Trade window slots
-		slot_id = IDX_TRADE_BAG + (bagslot_id-3000)*MAX_ITEMS_PER_BAG + bagidx;
-
-	return slot_id;
+// These are a temporary fix for Lua NativeType calls until resolved
+// DO NOT DIRECT CALL THESE!!
+int16 Inventory::CalcSlotId(int16 slot) {
+	return Legacy::CalcSlotId(slot);
 }
 
-// Opposite of above: Get parent bag slot_id from a slot inside of bag
-int16 Inventory::CalcSlotId(int16 slot_id)
-{
-	int16 parent_slot_id = SLOT_INVALID;
-
-	if (slot_id>=251 && slot_id<=330)
-		parent_slot_id = IDX_INV + (slot_id-251) / MAX_ITEMS_PER_BAG;
-	else if (slot_id>=331 && slot_id<=340)
-		parent_slot_id = SLOT_CURSOR;
-	else if (slot_id>=2000 && slot_id<=2023)
-		parent_slot_id = IDX_BANK + (slot_id-2000) / MAX_ITEMS_PER_BAG;
-	else if (slot_id>=2031 && slot_id<=2270)
-		parent_slot_id = IDX_BANK + (slot_id-2031) / MAX_ITEMS_PER_BAG;
-	else if (slot_id>=2531 && slot_id<=2550)
-		parent_slot_id = IDX_SHBANK + (slot_id-2531) / MAX_ITEMS_PER_BAG;
-	else if (slot_id>=3100 && slot_id<=3179)
-		parent_slot_id = IDX_TRADE + (slot_id-3100) / MAX_ITEMS_PER_BAG;
-
-	return parent_slot_id;
+int16 Inventory::CalcSlotId(int16 bag_slot, uint8 bag_index) {
+	return Legacy::CalcSlotId(bag_slot, bag_index);
 }
 
-uint8 Inventory::CalcBagIdx(int16 slot_id)
-{
-	uint8 index = 0;
-
-	if (slot_id>=251 && slot_id<=330)
-		index = (slot_id-251) % MAX_ITEMS_PER_BAG;
-	else if (slot_id>=331 && slot_id<=340)
-		index = (slot_id-331) % MAX_ITEMS_PER_BAG;
-	else if (slot_id>=2000 && slot_id<=2023)
-		index = (slot_id-2000) % MAX_ITEMS_PER_BAG;
-	else if (slot_id>=2031 && slot_id<=2270)
-		index = (slot_id-2031) % MAX_ITEMS_PER_BAG;
-	else if (slot_id>=2531 && slot_id<=2550)
-		index = (slot_id-2531) % MAX_ITEMS_PER_BAG;
-	else if (slot_id>=3100 && slot_id<=3179)
-		index = (slot_id-3100) % MAX_ITEMS_PER_BAG;
-	else if (slot_id>=4000 && slot_id<=4009)
-		index = (slot_id-4000) % MAX_ITEMS_PER_BAG;
-
-	return index;
+uint8 Inventory::CalcBagIdx(int16 slot) {
+	return Legacy::CalcBagIdx(slot);
 }
+//
 
 int16 Inventory::CalcSlotFromMaterial(uint8 material)
 {
 	switch(material)
 	{
 		case MaterialHead:
-			return SLOT_HEAD;
+			return Legacy::SLOT_HEAD;
 		case MaterialChest:
-			return SLOT_CHEST;
+			return Legacy::SLOT_CHEST;
 		case MaterialArms:
-			return SLOT_ARMS;
+			return Legacy::SLOT_ARMS;
 		case MaterialWrist:
-			return SLOT_BRACER01;	// there's 2 bracers, only one bracer material
+			return Legacy::SLOT_BRACER01;	// there's 2 bracers, only one bracer material
 		case MaterialHands:
-			return SLOT_HANDS;
+			return Legacy::SLOT_HANDS;
 		case MaterialLegs:
-			return SLOT_LEGS;
+			return Legacy::SLOT_LEGS;
 		case MaterialFeet:
-			return SLOT_FEET;
+			return Legacy::SLOT_FEET;
 		case MaterialPrimary:
-			return SLOT_PRIMARY;
+			return Legacy::SLOT_PRIMARY;
 		case MaterialSecondary:
-			return SLOT_SECONDARY;
+			return Legacy::SLOT_SECONDARY;
 		default:
-			return SLOT_INVALID;
+			return Legacy::SLOT_INVALID;
 	}
 }
 
@@ -1817,24 +1766,24 @@ uint8 Inventory::CalcMaterialFromSlot(int16 equipslot)
 {
 	switch(equipslot)
 	{
-		case SLOT_HEAD:
+		case Legacy::SLOT_HEAD:
 			return MaterialHead;
-		case SLOT_CHEST:
+		case Legacy::SLOT_CHEST:
 			return MaterialChest;
-		case SLOT_ARMS:
+		case Legacy::SLOT_ARMS:
 			return MaterialArms;
-		case SLOT_BRACER01:
-		case SLOT_BRACER02:
+		case Legacy::SLOT_BRACER01:
+		case Legacy::SLOT_BRACER02:
 			return MaterialWrist;
-		case SLOT_HANDS:
+		case Legacy::SLOT_HANDS:
 			return MaterialHands;
-		case SLOT_LEGS:
+		case Legacy::SLOT_LEGS:
 			return MaterialLegs;
-		case SLOT_FEET:
+		case Legacy::SLOT_FEET:
 			return MaterialFeet;
-		case SLOT_PRIMARY:
+		case Legacy::SLOT_PRIMARY:
 			return MaterialPrimary;
-		case SLOT_SECONDARY:
+		case Legacy::SLOT_SECONDARY:
 			return MaterialSecondary;
 		default:
 			return _MaterialInvalid;
@@ -1848,7 +1797,7 @@ bool Inventory::SupportsContainers(int16 slot_id)
 	if ((slot_id>=22 && slot_id<=30) ||		// Personal inventory slots
 		(slot_id>=2000 && slot_id<=2023) ||	// Bank slots
 		(slot_id>=2500 && slot_id<=2501) ||	// Shared bank slots
-		(slot_id==SLOT_CURSOR) ||			// Cursor
+		(slot_id==Legacy::SLOT_CURSOR) ||			// Cursor
 		(slot_id>=3000 && slot_id<=3007))	// Trade window
 		return true;
 	return false;
diff --git a/common/Item.h b/common/Item.h
index 33f0ff1..9fc841c 100644
--- a/common/Item.h
+++ b/common/Item.h
@@ -33,7 +33,7 @@ class EvolveInfo;			// Stores information about an evolving item family
 #include <vector>
 #include <map>
 #include <list>
-#include "../common/eq_packet_structs.h"
+//#include "../common/eq_packet_structs.h"
 #include "../common/eq_constants.h"
 #include "../common/item_struct.h"
 #include "../common/timer.h"
@@ -43,10 +43,8 @@ typedef std::list<ItemInst*>::const_iterator				iter_queue;
 typedef std::map<int16, ItemInst*>::const_iterator			iter_inst;
 typedef std::map<uint8, ItemInst*>::const_iterator			iter_contents;
 
-namespace ItemField
-{
-	enum
-	{
+namespace ItemField {
+	enum {
 		source = 0,
 #define F(x) x,
 #include "item_fieldlist.h"
@@ -55,24 +53,8 @@ namespace ItemField
 	};
 };
 
-// Indexing positions to the beginning slot_id's for a bucket of slots
-#define IDX_EQUIP		0
-#define IDX_CURSOR_BAG	331
-#define IDX_INV			22
-#define IDX_INV_BAG		251
-#define IDX_TRIBUTE		400
-#define IDX_BANK		2000
-#define IDX_BANK_BAG	2031
-#define IDX_SHBANK		2500
-#define IDX_SHBANK_BAG	2531
-#define IDX_TRADE		3000
-#define IDX_TRADE_BAG	3031
-#define IDX_TRADESKILL	4000
-#define MAX_ITEMS_PER_BAG 10
-
 // Specifies usage type for item inside ItemInst
-enum ItemInstTypes
-{
+enum ItemInstTypes {
 	ItemInstNormal = 0,
 	ItemInstWorldContainer
 };
@@ -88,19 +70,43 @@ typedef enum {
 //places with HasItem() and HasItemByUse()
 enum {
 	invWhereWorn		= 0x01,
-	invWherePersonal	= 0x02,	//in the character's inventory
+	invWherePersonal	= 0x02,	// in the character's inventory
 	invWhereBank		= 0x04,
 	invWhereSharedBank	= 0x08,
 	invWhereTrading		= 0x10,
-	invWhereCursor		= 0x20
+	invWhereCursor		= 0x20,
+	invWhereAll			= 0xFF
 };
 
+enum InventoryWhereLocation : uint32 {
+	WhereNull				= 0x00000000,
+	WhereEquipment			= 0x00000001,
+	WherePersonal			= 0x00000002,
+	WhereCursor				= 0x00000004,
+	WherePossessions		= 0x00000007,
+	WhereBank				= 0x00000008,
+	WhereSharedBank			= 0x00000010,
+	WhereTrade				= 0x00000020,
+	WhereWorld				= 0x00000040,
+	WhereLimbo				= 0x00000080,
+	WhereTribute			= 0x00000100,			
+	WhereTrophyTribute		= 0x00000200,	
+	WhereLegacy				= 0x000003D5,
+	WhereDeleted			= 0x00000400,
+	WhereRealEstate			= 0x00000800,
+	WhereAltStorage			= 0x00001000, // Big Bank
+	WhereArchived			= 0x00002000,
+	WhereMail				= 0x00004000,
+	WhereKrono				= 0x00008000,
+	WhereOther				= 0x00010000,
+	WhereEnd				= 0x00020000,
+	WhereAll				= 0xFFFFFFFF
+};
 
 // ########################################
 // Class: Queue
 //	Queue that allows a read-only iterator
-class ItemInstQueue
-{
+class ItemInstQueue {
 public:
 	~ItemInstQueue();
 	/////////////////////////
@@ -128,8 +134,7 @@ protected:
 // ########################################
 // Class: Inventory
 //	Character inventory
-class Inventory
-{
+class Inventory {
 	friend class ItemInst;
 public:
 	///////////////////////////////
@@ -188,10 +193,13 @@ public:
 	// Locate an available inventory slot
 	int16 FindFreeSlot(bool for_bag, bool try_cursor, uint8 min_size = 0, bool is_arrow = false);
 
-	// Calculate slot_id for an item within a bag
-	static int16 CalcSlotId(int16 slot_id); // Calc parent bag's slot_id
-	static int16 CalcSlotId(int16 bagslot_id, uint8 bagidx); // Calc slot_id for item inside bag
-	static uint8 CalcBagIdx(int16 slot_id); // Calc bagidx for slot_id
+	// These are a temporary fix for Lua NativeType calls until resolved
+	// DO NOT DIRECT CALL THESE!!
+	static int16 CalcSlotId(int16 slot);
+	static int16 CalcSlotId(int16 bag_slot, uint8 bag_index);
+	static uint8 CalcBagIdx(int16 slot);
+
+
 	static int16 CalcSlotFromMaterial(uint8 material);
 	static uint8 CalcMaterialFromSlot(int16 equipslot);
 
@@ -253,8 +261,7 @@ class SharedDatabase;
 //	Base class for an instance of an item
 //	An item instance encapsulates item data + data specific
 //	to an item instance (includes dye, augments, charges, etc)
-class ItemInst
-{
+class ItemInst {
 public:
 	/////////////////////////
 	// Methods
@@ -461,4 +468,372 @@ public:
 	~EvolveInfo();
 };
 
+struct AutoSlot_Struct : SlotPacket_Struct { // Self-invalidating slot struct with some basic functions
+	AutoSlot_Struct()						{ map = _INVALID; unknown02 = _NOTUSED; main = _INVALID; sub = _INVALID; aug = _INVALID; unknown01 = _NOTUSED; };
+	AutoSlot_Struct(Slot_Struct r)			{ map = r.map; unknown02 = _NOTUSED; main = r.main; sub = r.sub; aug = r.aug; unknown01 = _NOTUSED; };
+	AutoSlot_Struct(SlotPacket_Struct r)	{ map = r.map; unknown02 = r.unknown02; main = r.main; sub = r.sub; aug = r.aug; unknown01 = r.unknown01; };
+
+	void	Invalidate()	{ map = _INVALID; unknown02 = _NOTUSED; main = _INVALID; sub = _INVALID; aug = _INVALID; unknown01 = _NOTUSED; };
+
+	Slot_Struct			Slot()			{ Slot_Struct l; l.map = map; l.main = main; l.sub = sub; l.aug = aug; return l; };
+	SlotPacket_Struct	SlotPacket()	{ SlotPacket_Struct l; l.map = map; l.unknown02 = unknown02; l.main = main; l.sub = sub; l.aug = aug; l.unknown01 = unknown01; return l; };
+
+	bool	IsInvalid()			{ return (!(~map) && !(unknown02) && !(~main) && !(~sub) && !(~aug) && !(unknown01)); };
+	bool	IsDeleteRequest()	{ return (!(~map) && !(~main) && !(~sub) && !(~aug)); };
+
+	bool	IsMainItem()	{ return ((~main) && !(~sub) && !(~aug)); };
+	bool	IsMainAugment()	{ return ((~main) && !(~sub) && (~aug)); };
+	bool	IsSubItem()		{ return ((~main) && (~sub) && !(~aug)); };
+	bool	IsSubAugment()	{ return ((~main) && (~sub) && (~aug)); };
+
+	void	operator = (Slot_Struct r)			{ map = r.map; unknown02 = _NOTUSED; main = r.main; sub = r.sub; aug = r.aug; unknown01 = _NOTUSED; };
+	void	operator = (SlotPacket_Struct r)	{ map = r.map; unknown02 = r.unknown02; main = r.main; sub = r.sub; aug = r.aug; unknown01 = r.unknown01; };
+	void	operator = (AutoSlot_Struct r)		{ map = r.map; unknown02 = r.unknown02; main = r.main; sub = r.sub; aug = r.aug; unknown01 = r.unknown01; };
+
+	bool	operator == (Slot_Struct r)			{ return ((map == r.map) && (main == r.main) && (sub == r.sub) && (aug == r.aug)); };
+	bool	operator == (SlotPacket_Struct r)	{ return ((map == r.map) && (unknown02 == r.unknown02) && (main == r.main) && (sub = r.sub) && (aug == r.aug) && (unknown01 == r.unknown01)); };
+	bool	operator == (AutoSlot_Struct r)		{ return ((map == r.map) && (unknown02 == r.unknown02) && (main == r.main) && (sub = r.sub) && (aug == r.aug) && (unknown01 == r.unknown01)); };
+};
+
+namespace Legacy {
+	enum invWhere : uint8 {
+		invWhereNull		= 0x00,
+		invWhereWorn		= 0x01,
+		invWherePersonal	= 0x02,	// in the character's inventory
+		invWhereBank		= 0x04,
+		invWhereSharedBank	= 0x08,
+		invWhereTrading		= 0x10,
+		invWhereCursor		= 0x20,
+		invWhereAll			= 0xFF
+	};
+
+	enum BucketIndexing {
+		IDX_EQUIP			= 0,
+		IDX_CURSOR_BAG		= 331,
+		IDX_INV				= 22,
+		IDX_INV_BAG			= 251,
+		IDX_TRIBUTE			= 400,
+		IDX_BANK			= 2000,
+		IDX_BANK_BAG		= 2031,
+		IDX_SHBANK			= 2500,
+		IDX_SHBANK_BAG		= 2531,
+		IDX_TRADE			= 3000,
+		IDX_TRADE_BAG		= 3031,
+		IDX_TRADESKILL		= 4000,
+		MAX_ITEMS_PER_BAG	= 10
+	};
+
+	static int16 StructToSlot(Slot_Struct s_struct) {
+		int16 return_slot = _INVALID;
+		
+		if(s_struct.aug == _INVALID) {
+			switch(s_struct.map) {
+			case MapPossessions:
+				if((s_struct.main <= 20) && (s_struct.main >= 0)) {
+					if(s_struct.sub == _INVALID)
+						return_slot = s_struct.main;
+
+					break;
+				}
+				
+				if(s_struct.main == 21) {
+					if(s_struct.sub == _INVALID)
+						return_slot = 9999;
+
+					break;
+				}
+
+				if(s_struct.main == 22) {
+					if(s_struct.sub == _INVALID)
+						return_slot = 21;
+
+					break;
+				}
+
+				if((s_struct.main <= 30) && (s_struct.main >= 23)) {
+					if(s_struct.sub == _INVALID) {
+						return_slot = (s_struct.main - 1);
+					}
+					else if((s_struct.sub <= 9) && (s_struct.sub >= 0)) {
+						return_slot = (251 + ((s_struct.main - 23) * 10) + s_struct.sub);
+					}
+
+					break;
+				}
+
+				if(s_struct.main == 33) {
+					if(s_struct.sub == _INVALID) {
+						return_slot = 30;
+					}
+					else if((s_struct.sub <= 9) && (s_struct.sub >= 0)) {
+						return_slot = (331 + s_struct.sub);
+					}
+
+					break;
+				}
+
+				break;
+			case MapBank:
+				if((s_struct.main <= 23) && (s_struct.main >= 0)) {
+					if(s_struct.sub == _INVALID) {
+						return_slot = (2000 + s_struct.main);
+					}
+					else if((s_struct.sub <= 9) && (s_struct.sub >= 0)) {
+						return_slot = (2031 + (s_struct.main * 10) + s_struct.sub);
+					}
+
+					break;
+				}
+
+				break;
+			case MapSharedBank:
+				if((s_struct.main <= 1) && (s_struct.main >= 0)) {
+					if(s_struct.sub == _INVALID) {
+						return_slot = (2500 + s_struct.main);
+					}
+					else if((s_struct.sub <= 9) && (s_struct.sub >= 0)) {
+						return_slot = (2531 + (s_struct.main * 10) + s_struct.sub);
+					}
+
+					break;
+				}
+
+				break;
+			case MapTrade:
+				if((s_struct.main <= 7) && (s_struct.main >= 0)) {
+					if(s_struct.sub == _INVALID) {
+						return_slot = (3000 + s_struct.main);
+					}
+					else if((s_struct.sub <= 9) && (s_struct.sub >= 0)) {
+						return_slot = (3031 + (s_struct.main * 10) + s_struct.sub);
+					}
+
+					break;
+				}
+
+				break;
+			case MapWorld:
+				if((s_struct.main <= 9) && (s_struct.main >= 0)) {
+					if(s_struct.sub == _INVALID)
+						return_slot = (4000 + s_struct.main);
+
+					break;
+				}
+
+				break;
+			case MapLimbo:
+				if((s_struct.main <= 36) && (s_struct.main >= 0)) {
+					if(s_struct.sub == _INVALID)
+						return_slot = 30;
+
+					break;
+				}
+
+				break;
+			case MapTribute:
+				if((s_struct.main <= 4) && (s_struct.main >= 0)) {
+					if(s_struct.sub == _INVALID)
+						return_slot = (400 + s_struct.main);
+
+					break;
+				}
+
+				break;
+			default:
+				break;
+			}
+		}
+
+		return return_slot;
+	};
+
+	static Slot_Struct SlotToStruct(int16 slot) {
+		AutoSlot_Struct return_struct;
+
+		if((slot <= 20) && (slot >= 0)) {
+			return_struct.map = MapPossessions;
+			return_struct.main = slot;
+		}
+		else if(slot == 21) {
+			return_struct.map = MapPossessions;
+			return_struct.main = 22;
+		}
+		else if((slot <= 29) && (slot >= 22)) {
+			return_struct.map = MapPossessions;
+			return_struct.main = (slot + 1);
+		}
+		else if(slot == 30) {
+			return_struct.map = MapPossessions;
+			return_struct.main = 33;
+		}
+		else if((slot <= 330) && (slot >= 251)) {
+			return_struct.map = MapPossessions;
+			return_struct.main = ((slot - 251) / 10);
+			return_struct.sub = ((slot - 251) % 10);
+		}
+		else if((slot <= 340) && (slot >= 331)) {
+			return_struct.map = MapPossessions;
+			return_struct.main = ((slot - 331) / 10);
+			return_struct.sub = ((slot - 331) % 10);
+		}
+		else if((slot <= 404) && (slot >= 400)) {
+			return_struct.map = MapTribute;
+			return_struct.main = (slot - 400);
+		}
+		else if((slot <= 2023) && (slot >= 2000)) {
+			return_struct.map = MapBank;
+			return_struct.main = (slot - 2000);
+		}
+		else if((slot <= 2270) && (slot >= 2031)) {
+			return_struct.map = MapBank;
+			return_struct.main = ((slot - 2031) / 10);
+			return_struct.sub = ((slot - 2031) % 10);
+		}
+		else if((slot <= 2501) && (slot >= 2500)) {
+			return_struct.map = MapSharedBank;
+			return_struct.main = (slot - 2500);
+		}
+		else if((slot <= 2550) && (slot >= 2531)) {
+			return_struct.map = MapSharedBank;
+			return_struct.main = ((slot - 2531) / 10);
+			return_struct.sub = ((slot - 2531) % 10);
+		}
+		else if((slot <= 3007) && (slot >= 3000)) {
+			return_struct.map = MapTrade;
+			return_struct.main = (slot - 3000);
+		}
+		else if((slot <= 3110) && (slot >= 3031)) {
+			return_struct.map = MapTrade;
+			return_struct.main = ((slot - 3031) / 10);
+			return_struct.sub = ((slot - 3031) % 10);
+		}
+		else if((slot <= 4009) && (slot >= 4000)) {
+			return_struct.map = MapWorld;
+			return_struct.main = (slot - 4000);
+		}
+		else if(slot == 9999) {
+			return_struct.map = MapPossessions;
+			return_struct.main = 21;
+		}
+
+		return return_struct.Slot();
+	};
+
+	static int16 CalcSlotId(int16 slot) { // Return parent slot of bag slot
+		int16 return_slot = _INVALID;
+
+		if((slot <= 330) && (slot >= 251)) { // Personal bag slots
+			return_slot = (22 + (slot - 251) / 10);
+		}
+		else if((slot <= 340) && (slot >= 331)) { // Cursor bag slots
+			return_slot = 30;
+		}
+		/*
+		else if((slot <= 2023) && (slot >= 2000)) { // Bank slots - the enemy of my enemy is my friend? (didn't know they had a parent...)
+			return_slot = (2000 + (slot - 2000) / 10);
+		}
+		*/
+		else if((slot <= 2270) && (slot >= 2031)) { // Bank bag slots
+			return_slot = (2000 + (slot - 2031) / 10);
+		}
+		else if((slot <= 2550) && (slot >= 2531)) { // Shared Bank bag slots
+			return_slot = (2500 + (slot - 2531) / 10);
+		}
+		else if((slot <= 3179) && (slot >= 3100)) { // Trade bag slots
+			return_slot = (3000 + (slot - 3100) / 10);
+		}
+
+		return return_slot;
+	};
+
+	static int16 CalcSlotId(int16 bag_slot, uint8 bag_index) { // Return bag slot from parent slot and index
+		int16 return_slot = _INVALID;
+
+		// We already specify slot ranges for this check..anything out of range is returned as invalid
+		// if(!SupportsContainers(/* check gcc compliance */SlotToStruct(bag_slot)))
+		//	return return_slot;
+
+		// (Using code needs to validate bag existence and compare number of bagslots)
+		if((bag_slot == 30) || (bag_slot == 8000)) { // Cursor slot
+			return_slot = (331 + bag_index);
+		}
+		else if((bag_slot <= 29) && (bag_slot >= 22)) { // Personal slots
+			return_slot = (251 + (bag_slot - 22) * 10 + bag_index);
+		}
+		else if((bag_slot <= 2023) && (bag_slot >= 2000)) { // Bank slots
+			return_slot = (2031 + (bag_slot - 2000) * 10 + bag_index);
+		}
+		else if((bag_slot <= 2501) && (bag_slot >= 2500)) { // Shared Bank slots
+			return_slot = (2531 + (bag_slot - 2500) * 10 + bag_index);
+		}
+		else if((bag_slot <= 3007) && (bag_slot >= 3000)) { // Trade slots
+			return_slot = (3031 + (bag_slot - 3000) * 10 + bag_index);
+		}
+
+		return return_slot;
+	};
+
+	static uint8 CalcBagIdx(int16 slot) { // Return index from bag slot
+	// return_index = 0 is still a valid index (x mod x = 0)... I may change the behavior of the
+	// calling methods and return IS_INVALID (-1) if it can be done with minimal effort -U
+	
+		uint8 return_index = _NOTUSED;
+
+		if((slot <= 330) && (slot >= 251)) { // Personal bag slots
+			return_index = ((slot - 251) % 10);
+		}
+		else if((slot <= 340) && (slot >= 331)) { // Cursor bag slots
+			return_index = ((slot - 331) % 10);
+		}
+		/*
+		else if((slot <= 2023) && (slot >= 2000)) { // Bank slots - Again with the bank slots..they're not bags...
+			return_index = ((slot - 2000) % 10);
+		}
+		*/
+		else if((slot <= 2270) && (slot >= 2031)) { // Bank bag slots
+			return_index = ((slot - 2031) % 10);
+		}
+		else if((slot <= 2550) && (slot >= 2531)) { // Shared Bank bag slots
+			return_index = ((slot - 2531) % 10);
+		}
+		else if((slot <= 3179) && (slot >= 3100)) { // Trade bag slots
+			return_index = ((slot - 3100) % 10);
+		}
+		else if((slot <= 4009) && (slot >= 4000)) { // World container slots
+			return_index = /*(*/(slot - 4000) /* % 10) - wasted calculation */;
+		}
+
+		return return_index;
+	};
+
+	static uint32 WhereToInventoryWhereLocation(uint8 inv_where) {
+		if(inv_where == invWhereAll)
+			return WhereLegacy;
+
+		uint32 location = WhereNull;
+
+		if(inv_where & invWhereWorn)
+			location |= (WhereEquipment | WhereTribute);
+
+		if(inv_where & invWherePersonal)
+			location |= WherePersonal;
+
+		if(inv_where & invWhereBank)
+			location |= WhereBank;
+
+		if(inv_where & invWhereSharedBank)
+			location |= WhereSharedBank;
+
+		if(inv_where & invWhereTrading)
+			location |= WhereTrade;
+
+		if(inv_where & invWhereCursor)
+			location |= (WhereCursor | WhereLimbo);
+
+		return location;
+	};
+};
+
+
+
 #endif // #define __ITEM_H
diff --git a/common/clientversions.h b/common/clientversions.h
index 5836481..5b6a9fb 100644
--- a/common/clientversions.h
+++ b/common/clientversions.h
@@ -1,18 +1,18 @@
 #ifndef CLIENTVERSIONS_H
 #define CLIENTVERSIONS_H
 
-static const uint32 BIT_Client62 = 1;
-static const uint32 BIT_Titanium = 2;
-static const uint32 BIT_SoF = 4;
-static const uint32 BIT_SoD = 8;
-static const uint32 BIT_Underfoot = 16;
-static const uint32 BIT_RoF = 32;
-static const uint32 BIT_TitaniumAndEarlier = 3;
-static const uint32 BIT_SoFAndLater = 0xFFFFFFFC;
-static const uint32 BIT_SoDAndLater = 0xFFFFFFF8;
-static const uint32 BIT_UnderfootAndLater = 0xFFFFFFF0;
-static const uint32 BIT_RoFAndLater = 0xFFFFFFE0;
-static const uint32 BIT_AllClients = 0xFFFFFFFF;
+static const uint32	BIT_Client62			= 1;
+static const uint32	BIT_Titanium			= 2;
+static const uint32	BIT_SoF					= 4;
+static const uint32	BIT_SoD					= 8;
+static const uint32	BIT_Underfoot			= 16;
+static const uint32	BIT_RoF					= 32;
+static const uint32	BIT_TitaniumAndEarlier	= 3;
+static const uint32	BIT_SoFAndLater			= 0xFFFFFFFC;
+static const uint32	BIT_SoDAndLater			= 0xFFFFFFF8;
+static const uint32	BIT_UnderfootAndLater	= 0xFFFFFFF0;
+static const uint32	BIT_RoFAndLater			= 0xFFFFFFE0;
+static const uint32	BIT_AllClients			= 0xFFFFFFFF;
 
 typedef enum {
 	EQClientUnknown = 0,
@@ -21,7 +21,8 @@ typedef enum {
 	EQClientSoF,
 	EQClientSoD,
 	EQClientUnderfoot,
-	EQClientRoF
+	EQClientRoF,
+	_EQClientCount
 } EQClientVersion;
 
 #endif /* CLIENTVERSIONS_H */
diff --git a/common/eq_constants.h b/common/eq_constants.h
index d612017..51462aa 100644
--- a/common/eq_constants.h
+++ b/common/eq_constants.h
@@ -25,8 +25,7 @@
 **
 **	(There are no grepwin hits other than these declarations... Do they have a use?)
 */
-enum ItemAttributes : uint32
-{
+enum ItemAttributes : uint32 {
 	ItemAttrNone			= 0x00000000,
 	ItemAttrLore			= 0x00000001,
 	ItemAttrArtifact		= 0x00000002,
@@ -41,8 +40,7 @@ enum ItemAttributes : uint32
 **	Item class types
 **
 */
-enum ItemClassTypes
-{
+enum ItemClassTypes {
 	ItemClassCommon = 0,
 	ItemClassContainer,
 	ItemClassBook,
@@ -56,8 +54,7 @@ enum ItemClassTypes
 **
 **	(Looking at a recent database, it's possible that some of the item values may be off [10-27-2013] -U)
 */
-enum ItemUseTypes : uint8
-{
+enum ItemUseTypes : uint8 {
 /*9138*/	ItemType1HSlash = 0,
 /*9141*/	ItemType2HSlash,
 /*9140*/	ItemType1HPiercing,
@@ -144,8 +141,7 @@ enum ItemUseTypes : uint8
 **
 **	(ref: database, web forums and eqstr_us.txt)
 */
-enum ContainerUseTypes : uint8
-{
+enum ContainerUseTypes : uint8 {
 /*3400*/	BagTypeSmallBag = 0,
 /*3401*/	BagTypeLargeBag,
 /*3402*/	BagTypeQuiver,
@@ -354,8 +350,7 @@ typedef enum {
 #define MT_Stun					340
 
 //from showeq
-enum ChatColor
-{
+enum ChatColor {
 	CC_Default					= 0,
 	CC_DarkGrey					= 1,
 	CC_DarkGreen				= 2,
@@ -512,8 +507,7 @@ typedef enum {
 **
 **	(Another orphaned enumeration...)
 */
-enum RecastTimerTypes
-{
+enum RecastTimerTypes {
 	RecTimer_0 = 0,
 	RecTimer_1,
 	RecTimer_WeaponHealClick,		// 2
@@ -537,8 +531,7 @@ enum RecastTimerTypes
 	_RecTimerCount
 };
 
-enum GroupUpdateAction
-{
+enum GroupUpdateAction {
 	GUA_Joined = 0,
 	GUA_Left = 1,
 	GUA_LastLeft = 6,
@@ -557,8 +550,7 @@ static const uint8 DamageTypeUnknown	= 0xFF;
 **
 **	(indexed by 'Skill' of SkillUseTypes)
 */
-static const uint8 SkillDamageTypes[HIGHEST_SKILL + 1] = // change to _SkillServerArraySize once activated
-{
+static const uint8 SkillDamageTypes[HIGHEST_SKILL + 1] = {// change to _SkillServerArraySize once activated
 /*1HBlunt*/					0,
 /*1HSlashing*/				1,
 /*2HBlunt*/					0,
@@ -643,8 +635,7 @@ static const uint8 SkillDamageTypes[HIGHEST_SKILL + 1] = // change to _SkillServ
 **	Material use slots
 **
 */
-enum MaterialUseSlots : uint8
-{
+enum MaterialUseSlots : uint8 {
 	MaterialHead = 0,
 	MaterialChest,
 	MaterialArms,
@@ -658,11 +649,6 @@ enum MaterialUseSlots : uint8
 	_MaterialInvalid = 255
 };
 
-// Used for worn NPC inventory tracking. NPCs don't use
-// augments, so only the basic slots need to be kept track of.
-#define MAX_WORN_INVENTORY	22
-
-
 /*
 **	Inventory Slot Equipment Enum
 **	Mostly used for third-party tools to reference inventory slots
@@ -691,73 +677,162 @@ enum MaterialUseSlots : uint8
 **
 */
 
-enum InventorySlot
-{
-	////////////////////////
-	// Equip slots
-	////////////////////////
-
-	SLOT_CHARM		= 0,
-	SLOT_EAR01		= 1,
-	SLOT_HEAD		= 2,
-	SLOT_FACE		= 3,
-	SLOT_EAR02		= 4,
-	SLOT_NECK		= 5,
-	SLOT_SHOULDER	= 6,
-	SLOT_ARMS		= 7,
-	SLOT_BACK		= 8,
-	SLOT_BRACER01	= 9,
-	SLOT_BRACER02	= 10,
-	SLOT_RANGE		= 11,
-	SLOT_HANDS		= 12,
-	SLOT_PRIMARY	= 13,
-	SLOT_SECONDARY	= 14,
-	SLOT_RING01		= 15,
-	SLOT_RING02		= 16,
-	SLOT_CHEST		= 17,
-	SLOT_LEGS		= 18,
-	SLOT_FEET		= 19,
-	SLOT_WAIST		= 20,
-	SLOT_AMMO		= 21,
-
-	////////////////////////
-	// All other slots
-	////////////////////////
-	SLOT_PERSONAL_BEGIN = 22,
-	SLOT_PERSONAL_END = 29,
-
-	SLOT_CURSOR		= 30,
-
-	SLOT_CURSOR_END	= (int16)0xFFFE,	// Last item on cursor queue
-	// Cursor bag slots are 331->340 (10 slots)
-
-	// Personal Inventory Slots
-	// Slots 1 through 8 are slots 22->29
-	// Inventory bag slots are 251->330 (10 slots per bag)
-
-	// Tribute slots are 400-404? (upper bound unknown)
-	// storing these in worn item's map
-
-	// Bank slots
-	// Bank slots 1 through 16 are slots 2000->2015
-	// Bank bag slots are 2031->2190
-
-	// Shared bank slots
-	// Shared bank slots 1 through 2 are slots 2500->2501
-	// Shared bank bag slots are 2531->2550
-
-	// Trade session slots
-	// Trade slots 1 through 8 are slots 3000->3007
-	// Trade bag slots are technically 0->79 when passed to client,
-	// but in our code, we treat them as slots 3100->3179
-
-	// Slot used in OP_TradeSkillCombine for world tradeskill containers
-	SLOT_TRADESKILL = 1000,
-	SLOT_AUGMENT = 1001,
-	SLOT_POWER_SOURCE = 9999,
-	// Value recognized by client for destroying an item
-	SLOT_INVALID = (int16)0xFFFF
+// --------------------------------------------------------------------------------------------
+// THE FOLLOWING ENUMERATIONS SHOULD NOT BE CHANGED UNLESS DATABASE MAPPING IS UPDATED TO MATCH
+// --------------------------------------------------------------------------------------------
+enum InventoryMapTypes : int16 {
+	MapPossessions = 0,
+	MapBank,
+	MapSharedBank,
+	MapTrade,
+	MapWorld,
+	MapLimbo,
+	MapTribute,
+	MapTrophyTribute,
+	MapGuildTribute,
+	MapMerchant,
+	MapDeleted,
+	MapCorpse,
+	MapBazaar,
+	MapInspect,
+	MapRealEstate,
+	MapViewMODPC,
+	MapViewMODBank,
+	MapViewMODSharedBank,
+	MapViewMODLimbo,
+	MapAltStorage,
+	MapArchived,
+	MapMail,
+	MapGuildTrophyTribute,
+	MapKrono,
+	MapOther,
+	_MapCount
+};
+
+enum InventoryMainSlots : int16 {
+	SlotCharm = 0,
+	SlotEar1,
+	SlotHead,
+	SlotFace,
+	SlotEar2,
+	SlotNeck,
+	SlotShoulders,
+	SlotArms,
+	SlotBack,
+	SlotWrist1,
+	SlotWrist2,
+	SlotRange,
+	SlotHands,
+	SlotPrimary,
+	SlotSecondary,
+	SlotFinger1,
+	SlotFinger2,
+	SlotChest,
+	SlotLegs,
+	SlotFeet,
+	SlotWaist,
+	SlotPowerSource,
+	SlotAmmo,
+	SlotPersonal1,
+	SlotPersonal2,
+	SlotPersonal3,
+	SlotPersonal4,
+	SlotPersonal5,
+	SlotPersonal6,
+	SlotPersonal7,
+	SlotPersonal8,
+	SlotPersonal9,
+	SlotPersonal10,
+	SlotCursor,
+	_SlotCount
 };
 
+// TODO: move string returns for slot type and main slot names from clientlimits.cpp to here
+
+#define _NOTUSED	0
+#define _INVALID	-1
+
+// These are here because they are essential to replacing the 'int16 type slot'
+// Otherwise, there would be a lot of unnecessary '#include eq_packet_struct.h' directives
+struct Slot_Struct {
+/*0000*/	int16	map;
+/*0002*/	int16	main;
+/*0004*/	int16	sub;
+/*0006*/	int16	aug;
+/*0008*/
+};
+
+struct SlotPacket_Struct {
+/*0000*/	int16	map;
+/*0002*/	int16	unknown02;
+/*0004*/	int16	main;
+/*0006*/	int16	sub;
+/*0008*/	int16	aug;
+/*0010*/	int16	unknown01;
+/*0012*/
+};
+
+namespace Legacy {
+	enum InventorySlot {
+		SLOT_CHARM		= 0,
+		SLOT_EAR01		= 1,
+		SLOT_HEAD		= 2,
+		SLOT_FACE		= 3,
+		SLOT_EAR02		= 4,
+		SLOT_NECK		= 5,
+		SLOT_SHOULDER	= 6,
+		SLOT_ARMS		= 7,
+		SLOT_BACK		= 8,
+		SLOT_BRACER01	= 9,
+		SLOT_BRACER02	= 10,
+		SLOT_RANGE		= 11,
+		SLOT_HANDS		= 12,
+		SLOT_PRIMARY	= 13,
+		SLOT_SECONDARY	= 14,
+		SLOT_RING01		= 15,
+		SLOT_RING02		= 16,
+		SLOT_CHEST		= 17,
+		SLOT_LEGS		= 18,
+		SLOT_FEET		= 19,
+		SLOT_WAIST		= 20,
+		SLOT_AMMO		= 21,
+
+		SLOT_PERSONAL_BEGIN = 22,
+		MAX_WORN_INVENTORY = 22,
+		SLOT_PERSONAL_END = 29,
+
+		SLOT_CURSOR		= 30,
+
+		SLOT_CURSOR_END	= (int16)0xFFFE,	// Last item on cursor queue
+		// Cursor bag slots are 331->340 (10 slots)
+
+		// Personal Inventory Slots
+		// Slots 1 through 8 are slots 22->29
+		// Inventory bag slots are 251->330 (10 slots per bag)
+
+		// Tribute slots are 400-404? (upper bound unknown)
+		// storing these in worn item's map
+
+		// Bank slots
+		// Bank slots 1 through 16 are slots 2000->2015
+		// Bank bag slots are 2031->2190
+
+		// Shared bank slots
+		// Shared bank slots 1 through 2 are slots 2500->2501
+		// Shared bank bag slots are 2531->2550
+
+		// Trade session slots
+		// Trade slots 1 through 8 are slots 3000->3007
+		// Trade bag slots are technically 0->79 when passed to client,
+		// but in our code, we treat them as slots 3100->3179
+
+		// Slot used in OP_TradeSkillCombine for world tradeskill containers
+		SLOT_TRADESKILL = 1000,
+		SLOT_AUGMENT = 1001,
+		SLOT_POWER_SOURCE = 9999,
+		// Value recognized by client for destroying an item
+		SLOT_INVALID = (int16)0xFFFF
+	};
+};
 
 #endif
diff --git a/common/eq_packet_structs.h b/common/eq_packet_structs.h
index 0959ed3..ca6fe9c 100644
--- a/common/eq_packet_structs.h
+++ b/common/eq_packet_structs.h
@@ -5094,6 +5094,43 @@ struct ClientMarqueeMessage_Struct {
 	
 };
 
+/*
+	I also did some side work on the Marquee Message. This code may provide
+	some insight into finishing/expanding the current work -U
+
+enum MarqueeColors {
+	// names based on windows color class (game definitions are lacking)
+	// this enum encompasses the basic client coloring scheme..we should standardize the emu usage
+
+	MarqueeGray40	= 1,			// 0x606060 - I beleive this is the 'fall through' (default) mentioned above
+	MarqueeGreen	= 2,			// 0x008000
+	MarqueeNavy		= 4,			// 0x000080
+	MarqueeMagenta	= 5,			// 0xF000F0
+	MarqueeGray50	= 6,			// 0x808080
+	MarqueeGray90	= 7,			// 0xE0E0E0
+	MarqueeWhite	= 10,			// 0xF0F0F0
+	MarqueeGray60	= 12,			// 0xA0A0A0
+	MarqueeRed		= 13,			// 0xF00000
+	MarqueeLime		= 14,			// 0x00F000
+	MarqueeYellow	= 15,			// 0xF0F000
+	MarqueeBlue		= 16,			// 0x0000F0
+	MarqueeCyan		= 18,			// 0x00F0F0
+	MarqueeBlack	= 20,			// 0x000000
+	MarqueeOrange	= 21,			// 0xF0A000 - newer clients only
+	MarqueeBrown	= 22			// 0x806020 - newer clients only
+};
+
+struct MarqueeMessage_Struct {
+/*00* /	uint32	unknown01;		// possibly size, but MQ2 says different values have no effect (use 10)
+/*04* /	uint32	color;			// use MarqueeColors enumeration (MarqColor)
+/*08* /	uint32	opacity;		// 0 - 100
+/*12* /	uint32	fade_in;		// time in ms
+/*16* /	uint32	fade_out;		// time in ms
+/*20* /	uint32	hold;			// time in ms
+/*24* /	char	message[0];		// unsure if 256 or 4096 max
+};
+*/
+
 typedef std::list<ServerLootItem_Struct*> ItemList;
 
 // Restore structure packing to default
diff --git a/common/patches/RoF.cpp b/common/patches/RoF.cpp
index 3577fb6..827f89a 100644
--- a/common/patches/RoF.cpp
+++ b/common/patches/RoF.cpp
@@ -4625,7 +4625,7 @@ DECODE(OP_TradeSkillCombine) {
 
 	int16 slot_id = RoFToTitaniumSlot(eq->container_slot);
 	if (slot_id == 4000) {
-		slot_id = SLOT_TRADESKILL;	// 1000
+		slot_id = Legacy::SLOT_TRADESKILL;	// 1000
 	}
 	emu->container_slot = slot_id;
 
diff --git a/common/shareddb.cpp b/common/shareddb.cpp
index 132f329..775a582 100644
--- a/common/shareddb.cpp
+++ b/common/shareddb.cpp
@@ -229,7 +229,7 @@ bool SharedDatabase::SaveInventory(uint32 char_id, const ItemInst* inst, int16 s
 			// Delete bag slots, if need be
 			if (ret && Inventory::SupportsContainers(slot_id)) {
 				safe_delete_array(query);
-				int16 base_slot_id = Inventory::CalcSlotId(slot_id, 0);
+				int16 base_slot_id = Legacy::CalcSlotId(slot_id, 0);
 				ret = RunQuery(query, MakeAnyLenString(&query, "DELETE FROM sharedbank WHERE acctid=%i AND slotid>=%i AND slotid<%i",
 					account_id, base_slot_id, (base_slot_id+10)), errbuf);
 			}
@@ -268,7 +268,7 @@ bool SharedDatabase::SaveInventory(uint32 char_id, const ItemInst* inst, int16 s
 			// Delete bag slots, if need be
 			if (ret && Inventory::SupportsContainers(slot_id)) {
 				safe_delete_array(query);
-				int16 base_slot_id = Inventory::CalcSlotId(slot_id, 0);
+				int16 base_slot_id = Legacy::CalcSlotId(slot_id, 0);
 				ret = RunQuery(query, MakeAnyLenString(&query, "DELETE FROM inventory WHERE charid=%i AND slotid>=%i AND slotid<%i",
 					char_id, base_slot_id, (base_slot_id+10)), errbuf);
 			}
@@ -304,7 +304,7 @@ bool SharedDatabase::SaveInventory(uint32 char_id, const ItemInst* inst, int16 s
 	if (inst && inst->IsType(ItemClassContainer) && Inventory::SupportsContainers(slot_id)) {
 		for (uint8 idx=0; idx<10; idx++) {
 			const ItemInst* baginst = inst->GetItem(idx);
-			SaveInventory(char_id, baginst, Inventory::CalcSlotId(slot_id, idx));
+			SaveInventory(char_id, baginst, Legacy::CalcSlotId(slot_id, idx));
 		}
 	}
 
@@ -439,7 +439,7 @@ bool SharedDatabase::GetSharedBank(uint32 id, Inventory* inv, bool is_charid) {
 			const Item_Struct* item = GetItem(item_id);
 
 			if (item) {
-				int16 put_slot_id = SLOT_INVALID;
+				int16 put_slot_id = Legacy::SLOT_INVALID;
 
 				ItemInst* inst = CreateBaseItem(item, charges);
 				if (item->ItemClass == ItemClassCommon) {
@@ -479,7 +479,7 @@ bool SharedDatabase::GetSharedBank(uint32 id, Inventory* inv, bool is_charid) {
 				safe_delete(inst);
 
 				// Save ptr to item in inventory
-				if (put_slot_id == SLOT_INVALID) {
+				if (put_slot_id == Legacy::SLOT_INVALID) {
 					LogFile->write(EQEMuLog::Error,
 						"Warning: Invalid slot_id for item in shared bank inventory: %s=%i, item_id=%i, slot_id=%i",
 						((is_charid==true) ? "charid" : "acctid"), id, item_id, slot_id);
@@ -535,7 +535,7 @@ bool SharedDatabase::GetInventory(uint32 char_id, Inventory* inv) {
 			const Item_Struct* item = GetItem(item_id);
 
 			if (item) {
-				int16 put_slot_id = SLOT_INVALID;
+				int16 put_slot_id = Legacy::SLOT_INVALID;
 
 				ItemInst* inst = CreateBaseItem(item, charges);
 
@@ -589,7 +589,7 @@ bool SharedDatabase::GetInventory(uint32 char_id, Inventory* inv) {
 				safe_delete(inst);
 
 				// Save ptr to item in inventory
-				if (put_slot_id == SLOT_INVALID) {
+				if (put_slot_id == Legacy::SLOT_INVALID) {
 					LogFile->write(EQEMuLog::Error,
 						"Warning: Invalid slot_id for item in inventory: charid=%i, item_id=%i, slot_id=%i",
 						char_id, item_id, slot_id);
@@ -641,7 +641,7 @@ bool SharedDatabase::GetInventory(uint32 account_id, char* name, Inventory* inv)
 			aug[4]	= (uint32)atoi(row[8]);
 			bool instnodrop	= (row[9] && (uint16)atoi(row[9])) ? true : false;
 			const Item_Struct* item = GetItem(item_id);
-			int16 put_slot_id = SLOT_INVALID;
+			int16 put_slot_id = Legacy::SLOT_INVALID;
 			if(!item)
 				continue;
 
@@ -692,7 +692,7 @@ bool SharedDatabase::GetInventory(uint32 account_id, char* name, Inventory* inv)
 			safe_delete(inst);
 
 			// Save ptr to item in inventory
-			if (put_slot_id == SLOT_INVALID) {
+			if (put_slot_id == Legacy::SLOT_INVALID) {
 				LogFile->write(EQEMuLog::Error,
 					"Warning: Invalid slot_id for item in inventory: name=%s, acctid=%i, item_id=%i, slot_id=%i",
 					name, account_id, item_id, slot_id);
diff --git a/zone/MobAI.cpp b/zone/MobAI.cpp
index 5e6aad5..05cc226 100644
--- a/zone/MobAI.cpp
+++ b/zone/MobAI.cpp
@@ -844,7 +844,7 @@ void Client::AI_Process()
 									int16 ExtraAttackChanceBonus = spellbonuses.ExtraAttackChance + itembonuses.ExtraAttackChance + aabonuses.ExtraAttackChance;
 
 									if (ExtraAttackChanceBonus && GetTarget()) {
-										ItemInst *wpn = GetInv().GetItem(SLOT_PRIMARY);
+										ItemInst *wpn = GetInv().GetItem(Legacy::SLOT_PRIMARY);
 										if(wpn){
 											if(wpn->GetItem()->ItemType == ItemType2HSlash ||
 												wpn->GetItem()->ItemType == ItemType2HBlunt ||
diff --git a/zone/Object.cpp b/zone/Object.cpp
index 1f4dc36..c159ead 100644
--- a/zone/Object.cpp
+++ b/zone/Object.cpp
@@ -349,7 +349,7 @@ void Object::Close() {
 		ItemInst* container = this->m_inst;
 		if(container != nullptr)
 		{
-			for (uint8 i = 0; i < MAX_ITEMS_PER_BAG; i++)
+			for (uint8 i = 0; i < Legacy::MAX_ITEMS_PER_BAG; i++)
 			{
 				ItemInst* inst = container->PopItem(i);
 				if(inst != nullptr)
@@ -456,7 +456,7 @@ bool Object::HandleClick(Client* sender, const ClickObject_Struct* click_object)
 			// the client updates itself and takes care of sending "duplicate lore item" messages
 			if(sender->CheckLoreConflict(m_inst->GetItem())) {
 				int16 loreslot = sender->GetInv().HasItem(m_inst->GetItem()->ID, 0, invWhereBank);
-				if(loreslot != SLOT_INVALID) // if the duplicate is in the bank, delete it.
+				if(loreslot != Legacy::SLOT_INVALID) // if the duplicate is in the bank, delete it.
 					sender->DeleteItemInInventory(loreslot);
 				else
 					cursordelete = true;	// otherwise, we delete the new one
@@ -470,11 +470,11 @@ bool Object::HandleClick(Client* sender, const ClickObject_Struct* click_object)
 			parse->EventPlayer(EVENT_PLAYER_PICKUP, sender, buf, 0, &args);
 
 			// Transfer item to client
-			sender->PutItemInInventory(SLOT_CURSOR, *m_inst, false);
-			sender->SendItemPacket(SLOT_CURSOR, m_inst, ItemPacketTrade);
+			sender->PutItemInInventory(Legacy::SLOT_CURSOR, *m_inst, false);
+			sender->SendItemPacket(Legacy::SLOT_CURSOR, m_inst, ItemPacketTrade);
 
 			if(cursordelete)	// delete the item if it's a duplicate lore. We have to do this because the client expects the item packet
-				sender->DeleteItemInInventory(SLOT_CURSOR);
+				sender->DeleteItemInInventory(Legacy::SLOT_CURSOR);
 
 			if(!m_ground_spawn)
 				safe_delete(m_inst);
diff --git a/zone/attack.cpp b/zone/attack.cpp
index aa30557..741a262 100644
--- a/zone/attack.cpp
+++ b/zone/attack.cpp
@@ -1129,11 +1129,11 @@ bool Client::Attack(Mob* other, int Hand, bool bRiposte, bool IsStrikethrough, b
 
 	ItemInst* weapon;
 	if (Hand == 14){	// Kaiyodo - Pick weapon from the attacking hand
-		weapon = GetInv().GetItem(SLOT_SECONDARY);
+		weapon = GetInv().GetItem(Legacy::SLOT_SECONDARY);
 		OffHandAtk(true);
 	}
 	else{
-		weapon = GetInv().GetItem(SLOT_PRIMARY);
+		weapon = GetInv().GetItem(Legacy::SLOT_PRIMARY);
 		OffHandAtk(false);
 	}
 
@@ -1748,10 +1748,10 @@ bool NPC::Attack(Mob* other, int Hand, bool bRiposte, bool IsStrikethrough, bool
 
 	//figure out what weapon they are using, if any
 	const Item_Struct* weapon = nullptr;
-	if (Hand == 13 && equipment[SLOT_PRIMARY] > 0)
-		weapon = database.GetItem(equipment[SLOT_PRIMARY]);
-	else if (equipment[SLOT_SECONDARY])
-		weapon = database.GetItem(equipment[SLOT_SECONDARY]);
+	if (Hand == 13 && equipment[Legacy::SLOT_PRIMARY] > 0)
+		weapon = database.GetItem(equipment[Legacy::SLOT_PRIMARY]);
+	else if (equipment[Legacy::SLOT_SECONDARY])
+		weapon = database.GetItem(equipment[Legacy::SLOT_SECONDARY]);
 
 	//We dont factor much from the weapon into the attack.
 	//Just the skill type so it doesn't look silly using punching animations and stuff while wielding weapons
@@ -4316,7 +4316,7 @@ void Mob::DoRiposte(Mob* defender) {
 	if (!defender)
 		return;
 
-	defender->Attack(this, SLOT_PRIMARY, true);
+	defender->Attack(this, Legacy::SLOT_PRIMARY, true);
 	if (HasDied()) return;
 
 	int16 DoubleRipChance = defender->aabonuses.GiveDoubleRiposte[0] +
@@ -4326,7 +4326,7 @@ void Mob::DoRiposte(Mob* defender) {
 	//Live AA - Double Riposte
 	if(DoubleRipChance && (DoubleRipChance >= MakeRandomInt(0, 100))) {
 		mlog(COMBAT__ATTACKS, "Preforming a double riposed (%d percent chance)", DoubleRipChance);
-		defender->Attack(this, SLOT_PRIMARY, true);
+		defender->Attack(this, Legacy::SLOT_PRIMARY, true);
 		if (HasDied()) return;
 	}
 
diff --git a/zone/bonuses.cpp b/zone/bonuses.cpp
index bbb55f9..f0059ff 100644
--- a/zone/bonuses.cpp
+++ b/zone/bonuses.cpp
@@ -2468,7 +2468,7 @@ void NPC::CalcItemBonuses(StatBonuses *newbon)
 {
 	if(newbon){
 
-		for(int i = 0; i < MAX_WORN_INVENTORY; i++){
+		for(int i = 0; i < Legacy::MAX_WORN_INVENTORY; i++){
 			const Item_Struct *cur = database.GetItem(equipment[i]);
 			if(cur){
 				//basic stats
diff --git a/zone/bot.cpp b/zone/bot.cpp
index a87dd58..6cf8ff0 100644
--- a/zone/bot.cpp
+++ b/zone/bot.cpp
@@ -237,7 +237,7 @@ void Bot::SetBotSpellID(uint32 newSpellID) {
 uint32 Bot::GetBotArcheryRange() {
 	uint32 result = 0;
 
-	ItemInst* rangeItem = GetBotItem(SLOT_RANGE);
+	ItemInst* rangeItem = GetBotItem(Legacy::SLOT_RANGE);
 
 	if(!rangeItem)
 		return 0;
@@ -257,7 +257,7 @@ uint32 Bot::GetBotArcheryRange() {
 		archeryColor = botweapon->Color;
 		range =+ botweapon->Range;
 
-		rangeItem = GetBotItem(SLOT_AMMO);
+		rangeItem = GetBotItem(Legacy::SLOT_AMMO);
 		if(rangeItem)
 			botweapon = rangeItem->GetItem();
 
@@ -280,8 +280,8 @@ void Bot::ChangeBotArcherWeapons(bool isArcher) {
 		|| (GetClass()==SHADOWKNIGHT) || (GetClass()==ROGUE))
 	{
 		if(!isArcher) {
-			BotAddEquipItem(SLOT_PRIMARY, GetBotItemBySlot(SLOT_PRIMARY));
-			BotAddEquipItem(SLOT_SECONDARY, GetBotItemBySlot(SLOT_SECONDARY));
+			BotAddEquipItem(Legacy::SLOT_PRIMARY, GetBotItemBySlot(Legacy::SLOT_PRIMARY));
+			BotAddEquipItem(Legacy::SLOT_SECONDARY, GetBotItemBySlot(Legacy::SLOT_SECONDARY));
 			//archerbot->SendWearChange(MATERIAL_PRIMARY);
 			//archerbot->SendWearChange(MATERIAL_SECONDARY);
 			SetAttackTimer();
@@ -290,11 +290,11 @@ void Bot::ChangeBotArcherWeapons(bool isArcher) {
 		else {
 			//archerbot->SendWearChange(MATERIAL_PRIMARY);
 			//archerbot->SendWearChange(MATERIAL_SECONDARY);
-			BotRemoveEquipItem(SLOT_PRIMARY);
-			BotRemoveEquipItem(SLOT_SECONDARY);
+			BotRemoveEquipItem(Legacy::SLOT_PRIMARY);
+			BotRemoveEquipItem(Legacy::SLOT_SECONDARY);
 			//archerbot->SendBotArcheryWearChange(MATERIAL_PRIMARY, archeryMaterial, archeryColor);
-			BotAddEquipItem(SLOT_AMMO, GetBotItemBySlot(SLOT_AMMO));
-			BotAddEquipItem(SLOT_SECONDARY, GetBotItemBySlot(SLOT_RANGE));
+			BotAddEquipItem(Legacy::SLOT_AMMO, GetBotItemBySlot(Legacy::SLOT_AMMO));
+			BotAddEquipItem(Legacy::SLOT_SECONDARY, GetBotItemBySlot(Legacy::SLOT_RANGE));
 			SetAttackTimer();
 			Say("My bow is true and ready.");
 		}
@@ -1291,7 +1291,7 @@ void Bot::GenerateArmorClass()
 uint16 Bot::GetPrimarySkillValue()
 {
 	SkillUseTypes skill = HIGHEST_SKILL; //because nullptr == 0, which is 1H Slashing, & we want it to return 0 from GetSkill
-	bool equiped = m_inv.GetItem(SLOT_PRIMARY);
+	bool equiped = m_inv.GetItem(Legacy::SLOT_PRIMARY);
 
 	if(!equiped)
 	{
@@ -1299,7 +1299,7 @@ uint16 Bot::GetPrimarySkillValue()
 	}
 	else
 	{
-		uint8 type = m_inv.GetItem(SLOT_PRIMARY)->GetItem()->ItemType; //is this the best way to do this?
+		uint8 type = m_inv.GetItem(Legacy::SLOT_PRIMARY)->GetItem()->ItemType; //is this the best way to do this?
 		switch(type)
 		{
 			case ItemType1HSlash: // 1H Slashing
@@ -2622,7 +2622,7 @@ void Bot::LoadPet() {
 			NPC *pet = GetPet()->CastToNPC();
 			SpellBuff_Struct petBuffs[BUFF_COUNT];
 			memset(petBuffs, 0, sizeof(petBuffs));
-			uint32 petItems[MAX_WORN_INVENTORY];
+			uint32 petItems[Legacy::MAX_WORN_INVENTORY];
 
 			LoadPetBuffs(petBuffs, PetSaveId);
 			LoadPetItems(petItems, PetSaveId);
@@ -2739,7 +2739,7 @@ void Bot::LoadPetItems(uint32* petItems, uint32 botPetSaveId) {
 			int ItemCount = 0;
 
 			while(DataRow = mysql_fetch_row(DatasetResult)) {
-				if(ItemCount == MAX_WORN_INVENTORY)
+				if(ItemCount == Legacy::MAX_WORN_INVENTORY)
 					break;
 
 				petItems[ItemCount] = atoi(DataRow[0]);
@@ -2777,7 +2777,7 @@ void Bot::SavePet() {
 		uint32 botPetId = pet->CastToNPC()->GetPetSpellID();
 		char* tempPetName = new char[64];
 		SpellBuff_Struct petBuffs[BUFF_COUNT];
-		uint32 petItems[MAX_WORN_INVENTORY];
+		uint32 petItems[Legacy::MAX_WORN_INVENTORY];
 
 		pet->GetPetState(petBuffs, petItems, tempPetName);
 
@@ -2859,7 +2859,7 @@ void Bot::SavePetItems(uint32* petItems, uint32 botPetSaveId) {
 		char TempErrorMessageBuffer[MYSQL_ERRMSG_SIZE];
 		int ItemCount = 0;
 
-		while(ItemCount < MAX_WORN_INVENTORY) {
+		while(ItemCount < Legacy::MAX_WORN_INVENTORY) {
 			if(petItems[ItemCount] > 0) {
 				if(!database.RunQuery(Query, MakeAnyLenString(&Query, "INSERT INTO botpetinventory (BotPetsId, ItemId) VALUES(%u, %u);", botPetSaveId, petItems[ItemCount]), TempErrorMessageBuffer)) {
 					errorMessage = std::string(TempErrorMessageBuffer);
@@ -3181,12 +3181,12 @@ void Bot::BotRangedAttack(Mob* other) {
 		return;
 	}
 
-	ItemInst* rangedItem = GetBotItem(SLOT_RANGE);
+	ItemInst* rangedItem = GetBotItem(Legacy::SLOT_RANGE);
 	const Item_Struct* RangeWeapon = 0;
 	if(rangedItem)
 		RangeWeapon = rangedItem->GetItem();
 
-	ItemInst* ammoItem = GetBotItem(SLOT_AMMO);
+	ItemInst* ammoItem = GetBotItem(Legacy::SLOT_AMMO);
 	const Item_Struct* Ammo = 0;
 	if(ammoItem)
 		Ammo = ammoItem->GetItem();
@@ -3352,7 +3352,7 @@ void Bot::DoMeleeSkillAttackDmg(Mob* other, uint16 weapon_damage, SkillUseTypes
 		damage = -5;
 
 	if(skillinuse == SkillBash){
-		const ItemInst* inst = GetBotItem(SLOT_SECONDARY);
+		const ItemInst* inst = GetBotItem(Legacy::SLOT_SECONDARY);
 		const Item_Struct* botweapon = 0;
 		if(inst)
 			botweapon = inst->GetItem();
@@ -3398,17 +3398,17 @@ void Bot::ApplySpecialAttackMod(SkillUseTypes skill, int32 &dmg, int32 &mindmg)
 		case SkillFlyingKick:
 		case SkillRoundKick:
 		case SkillKick:
-			item_slot = SLOT_FEET;
+			item_slot = Legacy::SLOT_FEET;
 		break;
 
 		case SkillBash:
-			item_slot = SLOT_SECONDARY;
+			item_slot = Legacy::SLOT_SECONDARY;
 		break;
 
 		case SkillDragonPunch:
 		case SkillEagleStrike:
 		case SkillTigerClaw:
-			item_slot = SLOT_HANDS;
+			item_slot = Legacy::SLOT_HANDS;
 		break;
 	}
 
@@ -3760,27 +3760,27 @@ void Bot::AI_Process() {
 
 				//try main hand first
 				if(attack_timer.Check()) {
-					Attack(GetTarget(), SLOT_PRIMARY);
+					Attack(GetTarget(), Legacy::SLOT_PRIMARY);
 
-					ItemInst *wpn = GetBotItem(SLOT_PRIMARY);
-					TryWeaponProc(wpn, GetTarget(), SLOT_PRIMARY);
+					ItemInst *wpn = GetBotItem(Legacy::SLOT_PRIMARY);
+					TryWeaponProc(wpn, GetTarget(), Legacy::SLOT_PRIMARY);
 
 					bool tripleSuccess = false;
 
 					if(BotOwner && GetTarget() && CanThisClassDoubleAttack()) {
 
 						if(BotOwner && CheckBotDoubleAttack()) {
-							Attack(GetTarget(), SLOT_PRIMARY, true);
+							Attack(GetTarget(), Legacy::SLOT_PRIMARY, true);
 						}
 
 						if(BotOwner && GetTarget() && GetSpecialAbility(SPECATK_TRIPLE) && CheckBotDoubleAttack(true)) {
 							tripleSuccess = true;
-							Attack(GetTarget(), SLOT_PRIMARY, true);
+							Attack(GetTarget(), Legacy::SLOT_PRIMARY, true);
 						}
 
 						//quad attack, does this belong here??
 						if(BotOwner && GetTarget() && GetSpecialAbility(SPECATK_QUAD) && CheckBotDoubleAttack(true)) {
-							Attack(GetTarget(), SLOT_PRIMARY, true);
+							Attack(GetTarget(), Legacy::SLOT_PRIMARY, true);
 						}
 					}
 
@@ -3792,15 +3792,15 @@ void Bot::AI_Process() {
 						if(MakeRandomInt(0, 100) < flurrychance)
 						{
 							Message_StringID(MT_NPCFlurry, 128);
-							Attack(GetTarget(), SLOT_PRIMARY, false);
-							Attack(GetTarget(), SLOT_PRIMARY, false);
+							Attack(GetTarget(), Legacy::SLOT_PRIMARY, false);
+							Attack(GetTarget(), Legacy::SLOT_PRIMARY, false);
 						}
 					}
 
 					int16 ExtraAttackChanceBonus = spellbonuses.ExtraAttackChance + itembonuses.ExtraAttackChance + aabonuses.ExtraAttackChance;
 
 					if (GetTarget() && ExtraAttackChanceBonus) {
-						ItemInst *wpn = GetBotItem(SLOT_PRIMARY);
+						ItemInst *wpn = GetBotItem(Legacy::SLOT_PRIMARY);
 						if(wpn){
 							if(wpn->GetItem()->ItemType == ItemType2HSlash ||
 								wpn->GetItem()->ItemType == ItemType2HBlunt ||
@@ -3808,7 +3808,7 @@ void Bot::AI_Process() {
 							{
 								if(MakeRandomInt(0, 100) < ExtraAttackChanceBonus)
 								{
-									Attack(GetTarget(), SLOT_PRIMARY, false);
+									Attack(GetTarget(), Legacy::SLOT_PRIMARY, false);
 								}
 							}
 						}
@@ -3828,7 +3828,7 @@ void Bot::AI_Process() {
 
 				//now off hand
 				if(GetTarget() && attack_dw_timer.Check() && CanThisClassDualWield()) {
-					const ItemInst* instweapon = GetBotItem(SLOT_SECONDARY);
+					const ItemInst* instweapon = GetBotItem(Legacy::SLOT_SECONDARY);
 					const Item_Struct* weapon = 0;
 					//can only dual wield without a weapon if you're a monk
 					if(instweapon || (botClass == MONK)) {
@@ -3855,14 +3855,14 @@ void Bot::AI_Process() {
 
 							if (random < DualWieldProbability){ // Max 78% of DW
 
-								Attack(GetTarget(), SLOT_SECONDARY);	// Single attack with offhand
+								Attack(GetTarget(), Legacy::SLOT_SECONDARY);	// Single attack with offhand
 
-								ItemInst *wpn = GetBotItem(SLOT_SECONDARY);
-								TryWeaponProc(wpn, GetTarget(), SLOT_SECONDARY);
+								ItemInst *wpn = GetBotItem(Legacy::SLOT_SECONDARY);
+								TryWeaponProc(wpn, GetTarget(), Legacy::SLOT_SECONDARY);
 
 								if( CanThisClassDoubleAttack() && CheckBotDoubleAttack()) {
 									if(GetTarget() && GetTarget()->GetHP() > -10)
-										Attack(GetTarget(), SLOT_SECONDARY);	// Single attack with offhand
+										Attack(GetTarget(), Legacy::SLOT_SECONDARY);	// Single attack with offhand
 								}
 							}
 						}
@@ -4081,7 +4081,7 @@ void Bot::PetAIProcess() {
 					if(!botPet->BehindMob(botPet->GetTarget(), botPet->GetX(), botPet->GetY()) && botPet->GetTarget()->IsEnraged())
 						return;
 
-					if(botPet->Attack(GetTarget(), SLOT_PRIMARY))			// try the main hand
+					if(botPet->Attack(GetTarget(), Legacy::SLOT_PRIMARY))			// try the main hand
 						if (botPet->GetTarget())					// Do we still have a target?
 						{
 							// We're a pet so we re able to dual attack
@@ -4396,7 +4396,7 @@ void Bot::GetBotItems(std::string* errorMessage, Inventory &inv) {
 
 				ItemInst* inst = database.CreateItem(item_id, charges, aug[0], aug[1], aug[2], aug[3], aug[4]);
 				if(inst) {
-					int16 put_slot_id = SLOT_INVALID;
+					int16 put_slot_id = Legacy::SLOT_INVALID;
 					if(instnodrop || ((slot_id >= 0) && (slot_id <= 21) && inst->GetItem()->Attuneable))
 						inst->SetInstNoDrop(true);
 					if(color > 0)
@@ -4414,7 +4414,7 @@ void Bot::GetBotItems(std::string* errorMessage, Inventory &inv) {
 					safe_delete(inst);
 
 					// Save ptr to item in inventory
-					if (put_slot_id == SLOT_INVALID) {
+					if (put_slot_id == Legacy::SLOT_INVALID) {
 						LogFile->write(EQEMuLog::Error,
 							"Warning: Invalid slot_id for item in inventory: botid=%i, item_id=%i, slot_id=%i",
 							this->GetBotID(), item_id, slot_id);
@@ -4580,7 +4580,7 @@ void Bot::FillSpawnStruct(NewSpawn_Struct* ns, Mob* ForWho) {
 		uint32 spawnedbotid = 0;
 		spawnedbotid = this->GetBotID();
 
-		inst = GetBotItem(SLOT_HANDS);
+		inst = GetBotItem(Legacy::SLOT_HANDS);
 		if(inst) {
 			item = inst->GetItem();
 			if(item) {
@@ -4589,7 +4589,7 @@ void Bot::FillSpawnStruct(NewSpawn_Struct* ns, Mob* ForWho) {
 			}
 		}
 
-		inst = GetBotItem(SLOT_HEAD);
+		inst = GetBotItem(Legacy::SLOT_HEAD);
 		if(inst) {
 			item = inst->GetItem();
 			if(item) {
@@ -4598,7 +4598,7 @@ void Bot::FillSpawnStruct(NewSpawn_Struct* ns, Mob* ForWho) {
 			}
 		}
 
-		inst = GetBotItem(SLOT_ARMS);
+		inst = GetBotItem(Legacy::SLOT_ARMS);
 		if(inst) {
 			item = inst->GetItem();
 			if(item) {
@@ -4607,7 +4607,7 @@ void Bot::FillSpawnStruct(NewSpawn_Struct* ns, Mob* ForWho) {
 			}
 		}
 
-		inst = GetBotItem(SLOT_BRACER01);
+		inst = GetBotItem(Legacy::SLOT_BRACER01);
 		if(inst) {
 			item = inst->GetItem();
 			if(item) {
@@ -4616,7 +4616,7 @@ void Bot::FillSpawnStruct(NewSpawn_Struct* ns, Mob* ForWho) {
 			}
 		}
 
-		inst = GetBotItem(SLOT_BRACER02);
+		inst = GetBotItem(Legacy::SLOT_BRACER02);
 		if(inst) {
 			item = inst->GetItem();
 			if(item) {
@@ -4625,7 +4625,7 @@ void Bot::FillSpawnStruct(NewSpawn_Struct* ns, Mob* ForWho) {
 			}
 		}
 
-		inst = GetBotItem(SLOT_CHEST);
+		inst = GetBotItem(Legacy::SLOT_CHEST);
 		if(inst) {
 			item = inst->GetItem();
 			if(item) {
@@ -4634,7 +4634,7 @@ void Bot::FillSpawnStruct(NewSpawn_Struct* ns, Mob* ForWho) {
 			}
 		}
 
-		inst = GetBotItem(SLOT_LEGS);
+		inst = GetBotItem(Legacy::SLOT_LEGS);
 		if(inst) {
 			item = inst->GetItem();
 			if(item) {
@@ -4643,7 +4643,7 @@ void Bot::FillSpawnStruct(NewSpawn_Struct* ns, Mob* ForWho) {
 			}
 		}
 
-		inst = GetBotItem(SLOT_FEET);
+		inst = GetBotItem(Legacy::SLOT_FEET);
 		if(inst) {
 			item = inst->GetItem();
 			if(item) {
@@ -4652,7 +4652,7 @@ void Bot::FillSpawnStruct(NewSpawn_Struct* ns, Mob* ForWho) {
 			}
 		}
 
-		inst = GetBotItem(SLOT_PRIMARY);
+		inst = GetBotItem(Legacy::SLOT_PRIMARY);
 		if(inst) {
 			item = inst->GetItem();
 			if(item) {
@@ -4662,7 +4662,7 @@ void Bot::FillSpawnStruct(NewSpawn_Struct* ns, Mob* ForWho) {
 			}
 		}
 
-		inst = GetBotItem(SLOT_SECONDARY);
+		inst = GetBotItem(Legacy::SLOT_SECONDARY);
 		if(inst) {
 			item = inst->GetItem();
 			if(item) {
@@ -5972,7 +5972,7 @@ void Bot::FinishTrade(Client* client, BotTradeType tradeType) {
 		else if(tradeType == BotTradeClientNoDropNoTrade) {
 			// Items being traded are found on the Client's cursor slot, slot id 30. This item can be either a single item or it can be a bag.
 			// If it is a bag, then we have to search for items in slots 331 thru 340
-			PerformTradeWithClient(SLOT_CURSOR, SLOT_CURSOR, client);
+			PerformTradeWithClient(Legacy::SLOT_CURSOR, Legacy::SLOT_CURSOR, client);
 
 			// TODO: Add logic here to test if the item in SLOT_CURSOR is a container type, if it is then we need to call the following:
 			// PerformTradeWithClient(331, 340, client);
@@ -6001,7 +6001,7 @@ void Bot::PerformTradeWithClient(int16 beginSlotID, int16 endSlotID, Client* cli
 				charges[i] = inst->GetCharges();
 			}
 
-			if(i == SLOT_CURSOR)
+			if(i == Legacy::SLOT_CURSOR)
 				UpdateClient = true;
 
 			//EQoffline: will give the items to the bots and change the bot stats
@@ -6038,17 +6038,17 @@ void Bot::PerformTradeWithClient(int16 beginSlotID, int16 endSlotID, Client* cli
 						if((mWeaponItem->Slots & (1 << j))) {
 							how_many_slots++;
 							if(!GetBotItem(j)) {
-								if(j == SLOT_PRIMARY) {
+								if(j == Legacy::SLOT_PRIMARY) {
 									if((mWeaponItem->ItemType == ItemType2HSlash) || (mWeaponItem->ItemType == ItemType2HBlunt) || (mWeaponItem->ItemType == ItemType2HPiercing)) {
-										if(GetBotItem(SLOT_SECONDARY)) {
+										if(GetBotItem(Legacy::SLOT_SECONDARY)) {
 											if(mWeaponItem && (mWeaponItem->ItemType == ItemType2HSlash) || (mWeaponItem->ItemType == ItemType2HBlunt) || (mWeaponItem->ItemType == ItemType2HPiercing)) {
-												if(client->CheckLoreConflict(GetBotItem(SLOT_SECONDARY)->GetItem())) {
+												if(client->CheckLoreConflict(GetBotItem(Legacy::SLOT_SECONDARY)->GetItem())) {
 													failedLoreCheck = true;
 												}
 											}
 											else {
-												ItemInst* remove_item = GetBotItem(SLOT_SECONDARY);
-												BotTradeSwapItem(client, SLOT_SECONDARY, 0, remove_item, remove_item->GetItem()->Slots, &TempErrorMessage, false);
+												ItemInst* remove_item = GetBotItem(Legacy::SLOT_SECONDARY);
+												BotTradeSwapItem(client, Legacy::SLOT_SECONDARY, 0, remove_item, remove_item->GetItem()->Slots, &TempErrorMessage, false);
 											}
 										}
 									}
@@ -6058,7 +6058,7 @@ void Bot::PerformTradeWithClient(int16 beginSlotID, int16 endSlotID, Client* cli
 									}
 									break;
 								}
-								else if(j == SLOT_SECONDARY) {
+								else if(j == Legacy::SLOT_SECONDARY) {
 									if(inst->IsWeapon()) {
 										if(CanThisClassDualWield()) {
 											BotTradeAddItem(mWeaponItem->ID, inst, inst->GetCharges(), mWeaponItem->Slots, j, &TempErrorMessage);
@@ -6074,10 +6074,10 @@ void Bot::PerformTradeWithClient(int16 beginSlotID, int16 endSlotID, Client* cli
 										success = true;
 									}
 									if(success) {
-										if(GetBotItem(SLOT_PRIMARY)) {
-											ItemInst* remove_item = GetBotItem(SLOT_PRIMARY);
+										if(GetBotItem(Legacy::SLOT_PRIMARY)) {
+											ItemInst* remove_item = GetBotItem(Legacy::SLOT_PRIMARY);
 											if((remove_item->GetItem()->ItemType == ItemType2HSlash) || (remove_item->GetItem()->ItemType == ItemType2HBlunt) || (remove_item->GetItem()->ItemType == ItemType2HPiercing)) {
-												BotTradeSwapItem(client, SLOT_PRIMARY, 0, remove_item, remove_item->GetItem()->Slots, &TempErrorMessage, false);
+												BotTradeSwapItem(client, Legacy::SLOT_PRIMARY, 0, remove_item, remove_item->GetItem()->Slots, &TempErrorMessage, false);
 											}
 										}
 										break;
@@ -6109,28 +6109,28 @@ void Bot::PerformTradeWithClient(int16 beginSlotID, int16 endSlotID, Client* cli
 									failedLoreCheck = true;
 								}
 								if(!failedLoreCheck) {
-									if(j == SLOT_PRIMARY) {
+									if(j == Legacy::SLOT_PRIMARY) {
 										if((mWeaponItem->ItemType == ItemType2HSlash) || (mWeaponItem->ItemType == ItemType2HBlunt) || (mWeaponItem->ItemType == ItemType2HPiercing)) {
-											if(GetBotItem(SLOT_SECONDARY)) {
-												if(client->CheckLoreConflict(GetBotItem(SLOT_SECONDARY)->GetItem())) {
+											if(GetBotItem(Legacy::SLOT_SECONDARY)) {
+												if(client->CheckLoreConflict(GetBotItem(Legacy::SLOT_SECONDARY)->GetItem())) {
 													failedLoreCheck = true;
 												}
 												else {
-													ItemInst* remove_item = GetBotItem(SLOT_SECONDARY);
-													BotTradeSwapItem(client, SLOT_SECONDARY, 0, remove_item, remove_item->GetItem()->Slots, &TempErrorMessage, false);
+													ItemInst* remove_item = GetBotItem(Legacy::SLOT_SECONDARY);
+													BotTradeSwapItem(client, Legacy::SLOT_SECONDARY, 0, remove_item, remove_item->GetItem()->Slots, &TempErrorMessage, false);
 												}
 											}
 										}
 										if(!failedLoreCheck) {
-											BotTradeSwapItem(client, SLOT_PRIMARY, inst, swap_item, mWeaponItem->Slots, &TempErrorMessage);
+											BotTradeSwapItem(client, Legacy::SLOT_PRIMARY, inst, swap_item, mWeaponItem->Slots, &TempErrorMessage);
 											success = true;
 										}
 										break;
 									}
-									else if(j == SLOT_SECONDARY) {
+									else if(j == Legacy::SLOT_SECONDARY) {
 										if(inst->IsWeapon()) {
 											if(CanThisClassDualWield()) {
-												BotTradeSwapItem(client, SLOT_SECONDARY, inst, swap_item, mWeaponItem->Slots, &TempErrorMessage);
+												BotTradeSwapItem(client, Legacy::SLOT_SECONDARY, inst, swap_item, mWeaponItem->Slots, &TempErrorMessage);
 												success = true;
 											}
 											else {
@@ -6139,13 +6139,13 @@ void Bot::PerformTradeWithClient(int16 beginSlotID, int16 endSlotID, Client* cli
 											}
 										}
 										else {
-											BotTradeSwapItem(client, SLOT_SECONDARY, inst, swap_item, mWeaponItem->Slots, &TempErrorMessage);
+											BotTradeSwapItem(client, Legacy::SLOT_SECONDARY, inst, swap_item, mWeaponItem->Slots, &TempErrorMessage);
 											success = true;
 										}
-										if(success && GetBotItem(SLOT_PRIMARY)) {
-											ItemInst* remove_item = GetBotItem(SLOT_PRIMARY);
+										if(success && GetBotItem(Legacy::SLOT_PRIMARY)) {
+											ItemInst* remove_item = GetBotItem(Legacy::SLOT_PRIMARY);
 											if((remove_item->GetItem()->ItemType == ItemType2HSlash) || (remove_item->GetItem()->ItemType == ItemType2HBlunt) || (remove_item->GetItem()->ItemType == ItemType2HPiercing)) {
-												BotTradeSwapItem(client, SLOT_PRIMARY, 0, remove_item, remove_item->GetItem()->Slots, &TempErrorMessage, false);
+												BotTradeSwapItem(client, Legacy::SLOT_PRIMARY, 0, remove_item, remove_item->GetItem()->Slots, &TempErrorMessage, false);
 											}
 										}
 										break;
@@ -6404,12 +6404,12 @@ bool Bot::Attack(Mob* other, int Hand, bool FromRiposte, bool IsStrikethrough, b
 	FaceTarget(GetTarget());
 
 	ItemInst* weapon = nullptr;
-	if(Hand == SLOT_PRIMARY) {
-		weapon = GetBotItem(SLOT_PRIMARY);
+	if(Hand == Legacy::SLOT_PRIMARY) {
+		weapon = GetBotItem(Legacy::SLOT_PRIMARY);
 		OffHandAtk(false);
 	}
-	if(Hand == SLOT_SECONDARY) {
-		weapon = GetBotItem(SLOT_SECONDARY);
+	if(Hand == Legacy::SLOT_SECONDARY) {
+		weapon = GetBotItem(Legacy::SLOT_SECONDARY);
 		OffHandAtk(true);
 	}
 
@@ -6476,7 +6476,7 @@ bool Bot::Attack(Mob* other, int Hand, bool FromRiposte, bool IsStrikethrough, b
 
 		int ucDamageBonus = 0;
 
-		if( Hand == SLOT_PRIMARY && GetLevel() >= 28 && IsWarriorClass() )
+		if( Hand == Legacy::SLOT_PRIMARY && GetLevel() >= 28 && IsWarriorClass() )
 		{
 			// Damage bonuses apply only to hits from the main hand (Hand == 13) by characters level 28 and above
 			// who belong to a melee class. If we're here, then all of these conditions apply.
@@ -6489,7 +6489,7 @@ bool Bot::Attack(Mob* other, int Hand, bool FromRiposte, bool IsStrikethrough, b
 		}
 #endif
 		//Live AA - Sinister Strikes *Adds weapon damage bonus to offhand weapon.
-		if (Hand==SLOT_SECONDARY) {
+		if (Hand==Legacy::SLOT_SECONDARY) {
 			if (aabonuses.SecondaryDmgInc || itembonuses.SecondaryDmgInc || spellbonuses.SecondaryDmgInc){
 
 				ucDamageBonus = GetWeaponDamageBonus( weapon ? weapon->GetItem() : (const Item_Struct*) nullptr );
@@ -6546,7 +6546,7 @@ bool Bot::Attack(Mob* other, int Hand, bool FromRiposte, bool IsStrikethrough, b
 		if (damage == -3) {
 			if (FromRiposte) return false;
 			else {
-				if (Hand == SLOT_SECONDARY) {// Do we even have it & was attack with mainhand? If not, don't bother with other calculations
+				if (Hand == Legacy::SLOT_SECONDARY) {// Do we even have it & was attack with mainhand? If not, don't bother with other calculations
 					//Live AA - SlipperyAttacks
 					//This spell effect most likely directly modifies the actual riposte chance when using offhand attack.
 					int16 OffhandRiposteFail = aabonuses.OffhandRiposteFail + itembonuses.OffhandRiposteFail + spellbonuses.OffhandRiposteFail;
@@ -7751,13 +7751,13 @@ float Bot::GetProcChances(float &ProcBonus, float &ProcChance, uint16 weapon_spe
 		AABonus = float(aabonuses.ProcChance) / 100.0f;
 
 	switch(hand){
-		case SLOT_PRIMARY:
+		case Legacy::SLOT_PRIMARY:
 			weapon_speed = attack_timer.GetDuration();
 			break;
-		case SLOT_SECONDARY:
+		case Legacy::SLOT_SECONDARY:
 			weapon_speed = attack_dw_timer.GetDuration();
 			break;
-		case SLOT_RANGE:
+		case Legacy::SLOT_RANGE:
 			weapon_speed = ranged_timer.GetDuration();
 			break;
 	}
@@ -7878,9 +7878,9 @@ bool Bot::AvoidDamage(Mob* other, int32 &damage, bool CanRiposte)
 
 	if(damage > 0 && (aabonuses.ShieldBlock || spellbonuses.ShieldBlock || itembonuses.ShieldBlock)
 		&& (!other->BehindMob(this, other->GetX(), other->GetY()) || bShieldBlockFromRear)) {
-		bool equiped = GetBotItem(SLOT_SECONDARY);
+		bool equiped = GetBotItem(Legacy::SLOT_SECONDARY);
 		if(equiped) {
-			uint8 shield = GetBotItem(SLOT_SECONDARY)->GetItem()->ItemType;
+			uint8 shield = GetBotItem(Legacy::SLOT_SECONDARY)->GetItem()->ItemType;
 			float bonusShieldBlock = 0.0f;
 			if(shield == ItemTypeShield) {
 
@@ -7893,9 +7893,9 @@ bool Bot::AvoidDamage(Mob* other, int32 &damage, bool CanRiposte)
 
 	if(damage > 0 && (aabonuses.TwoHandBluntBlock || spellbonuses.TwoHandBluntBlock || itembonuses.TwoHandBluntBlock)
 		&& (!other->BehindMob(this, other->GetX(), other->GetY()) || bShieldBlockFromRear)) {
-		bool equiped2 = GetBotItem(SLOT_PRIMARY);
+		bool equiped2 = GetBotItem(Legacy::SLOT_PRIMARY);
 		if(equiped2) {
-			uint8 TwoHandBlunt = GetBotItem(SLOT_PRIMARY)->GetItem()->ItemType;
+			uint8 TwoHandBlunt = GetBotItem(Legacy::SLOT_PRIMARY)->GetItem()->ItemType;
 			float bonusStaffBlock = 0.0f;
 			if(TwoHandBlunt == ItemType2HBlunt) {
 
@@ -8033,7 +8033,7 @@ void Bot::DoRiposte(Mob* defender) {
 	if (!defender)
 		return;
 
-	defender->Attack(this, SLOT_PRIMARY, true);
+	defender->Attack(this, Legacy::SLOT_PRIMARY, true);
 
 	//double riposte
 	int16 DoubleRipChance = defender->GetAABonuses().GiveDoubleRiposte[0] +
@@ -8043,7 +8043,7 @@ void Bot::DoRiposte(Mob* defender) {
 	if(DoubleRipChance && (DoubleRipChance >= MakeRandomInt(0, 100))) {
 		mlog(COMBAT__ATTACKS, "Preforming a double riposte (%d percent chance)", DoubleRipChance);
 
-		defender->Attack(this, SLOT_PRIMARY, true);
+		defender->Attack(this, Legacy::SLOT_PRIMARY, true);
 	}
 
 	//Double Riposte effect, allows for a chance to do RIPOSTE with a skill specfic special attack (ie Return Kick).
@@ -8067,7 +8067,7 @@ void Bot::DoSpecialAttackDamage(Mob *who, SkillUseTypes skill, int32 max_damage,
 		hate = hate_override;
 
 	if(skill == SkillBash) {
-		const ItemInst* inst = GetBotItem(SLOT_SECONDARY);
+		const ItemInst* inst = GetBotItem(Legacy::SLOT_SECONDARY);
 		const Item_Struct* botweapon = 0;
 		if(inst)
 			botweapon = inst->GetItem();
@@ -8081,7 +8081,7 @@ void Bot::DoSpecialAttackDamage(Mob *who, SkillUseTypes skill, int32 max_damage,
 
 	min_damage += min_damage * GetMeleeMinDamageMod_SE(skill) / 100;
 
-	if(HitChance && !who->CheckHitChance(this, skill, SLOT_PRIMARY))
+	if(HitChance && !who->CheckHitChance(this, skill, Legacy::SLOT_PRIMARY))
 		max_damage = 0;
 
 	else{
@@ -8134,7 +8134,7 @@ void Bot::TryBackstab(Mob *other, int ReuseTime) {
 	bool bIsBehind = false;
 	bool bCanFrontalBS = false;
 
-	const ItemInst* inst = GetBotItem(SLOT_PRIMARY);
+	const ItemInst* inst = GetBotItem(Legacy::SLOT_PRIMARY);
 	const Item_Struct* botpiercer = nullptr;
 	if(inst)
 		botpiercer = inst->GetItem();
@@ -8220,7 +8220,7 @@ void Bot::RogueBackstab(Mob* other, bool min_damage, int ReuseTime)
 	int32 primaryweapondamage = 0;
 	int32 backstab_dmg = 0;
 
-	ItemInst* botweaponInst = GetBotItem(SLOT_PRIMARY);
+	ItemInst* botweaponInst = GetBotItem(Legacy::SLOT_PRIMARY);
 	if(botweaponInst) {
 		primaryweapondamage = GetWeaponDamage(other, botweaponInst);
 		backstab_dmg = botweaponInst->GetItem()->BackstabDmg;
@@ -8290,7 +8290,7 @@ void Bot::RogueBackstab(Mob* other, bool min_damage, int ReuseTime)
 
 void Bot::RogueAssassinate(Mob* other)
 {
-	ItemInst* botweaponInst = GetBotItem(SLOT_PRIMARY);
+	ItemInst* botweaponInst = GetBotItem(Legacy::SLOT_PRIMARY);
 	if(botweaponInst) {
 		if(GetWeaponDamage(other, botweaponInst)) {
 			other->Damage(this, 32000, SPELL_UNKNOWN, SkillBackstab);
@@ -8380,10 +8380,10 @@ void Bot::DoClassAttacks(Mob *target, bool IsRiposte) {
 		if(level >= RuleI(Combat, NPCBashKickLevel)){
 			bool canBash = false;
 			if((GetRace() == OGRE || GetRace() == TROLL || GetRace() == BARBARIAN) // Racial Slam
-						|| (m_inv.GetItem(SLOT_SECONDARY) && m_inv.GetItem(SLOT_SECONDARY)->GetItem()->ItemType == ItemTypeShield) //Using Shield
-						|| (m_inv.GetItem(SLOT_PRIMARY) && (m_inv.GetItem(SLOT_PRIMARY)->GetItem()->ItemType == ItemType2HSlash
-							|| m_inv.GetItem(SLOT_PRIMARY)->GetItem()->ItemType == ItemType2HBlunt
-							|| m_inv.GetItem(SLOT_PRIMARY)->GetItem()->ItemType == ItemType2HPiercing)
+						|| (m_inv.GetItem(Legacy::SLOT_SECONDARY) && m_inv.GetItem(Legacy::SLOT_SECONDARY)->GetItem()->ItemType == ItemTypeShield) //Using Shield
+						|| (m_inv.GetItem(Legacy::SLOT_PRIMARY) && (m_inv.GetItem(Legacy::SLOT_PRIMARY)->GetItem()->ItemType == ItemType2HSlash
+							|| m_inv.GetItem(Legacy::SLOT_PRIMARY)->GetItem()->ItemType == ItemType2HBlunt
+							|| m_inv.GetItem(Legacy::SLOT_PRIMARY)->GetItem()->ItemType == ItemType2HPiercing)
 							&& GetAA(aa2HandBash) >= 1)) { //Using 2 hand weapon, but has AA 2 Hand Bash
 				canBash = true;
 			}
@@ -8407,10 +8407,10 @@ void Bot::DoClassAttacks(Mob *target, bool IsRiposte) {
 	case PALADIN:
 		if(level >= RuleI(Combat, NPCBashKickLevel)){
 			if((GetRace() == OGRE || GetRace() == TROLL || GetRace() == BARBARIAN) // Racial Slam
-						|| (m_inv.GetItem(SLOT_SECONDARY) && m_inv.GetItem(SLOT_SECONDARY)->GetItem()->ItemType == ItemTypeShield) //Using Shield
-						|| (m_inv.GetItem(SLOT_PRIMARY) && (m_inv.GetItem(SLOT_PRIMARY)->GetItem()->ItemType == ItemType2HSlash
-							|| m_inv.GetItem(SLOT_PRIMARY)->GetItem()->ItemType == ItemType2HBlunt
-							|| m_inv.GetItem(SLOT_PRIMARY)->GetItem()->ItemType == ItemType2HPiercing)
+						|| (m_inv.GetItem(Legacy::SLOT_SECONDARY) && m_inv.GetItem(Legacy::SLOT_SECONDARY)->GetItem()->ItemType == ItemTypeShield) //Using Shield
+						|| (m_inv.GetItem(Legacy::SLOT_PRIMARY) && (m_inv.GetItem(Legacy::SLOT_PRIMARY)->GetItem()->ItemType == ItemType2HSlash
+							|| m_inv.GetItem(Legacy::SLOT_PRIMARY)->GetItem()->ItemType == ItemType2HBlunt
+							|| m_inv.GetItem(Legacy::SLOT_PRIMARY)->GetItem()->ItemType == ItemType2HPiercing)
 							&& GetAA(aa2HandBash) >= 1)) { //Using 2 hand weapon, but has AA 2 Hand Bash
 				skill_to_use = SkillBash;
 			}
@@ -8457,8 +8457,8 @@ void Bot::DoClassAttacks(Mob *target, bool IsRiposte) {
 		{
 			DoAnim(animTailRake);
 
-			if(GetWeaponDamage(target, GetBotItem(SLOT_SECONDARY)) <= 0 &&
-				GetWeaponDamage(target, GetBotItem(SLOT_SHOULDER)) <= 0){
+			if(GetWeaponDamage(target, GetBotItem(Legacy::SLOT_SECONDARY)) <= 0 &&
+				GetWeaponDamage(target, GetBotItem(Legacy::SLOT_SHOULDER)) <= 0){
 				dmg = -5;
 			}
 			else{
@@ -8533,7 +8533,7 @@ void Bot::DoClassAttacks(Mob *target, bool IsRiposte) {
 		{
 			DoAnim(animKick);
 
-			if(GetWeaponDamage(target, GetBotItem(SLOT_FEET)) <= 0){
+			if(GetWeaponDamage(target, GetBotItem(Legacy::SLOT_FEET)) <= 0){
 				dmg = -5;
 			}
 			else{
@@ -9005,14 +9005,14 @@ void Bot::SetAttackTimer() {
 	Timer* TimerToUse = nullptr;
 	const Item_Struct* PrimaryWeapon = nullptr;
 
-	for (int i=SLOT_RANGE; i<=SLOT_SECONDARY; i++) {
+	for (int i=Legacy::SLOT_RANGE; i<=Legacy::SLOT_SECONDARY; i++) {
 
 		//pick a timer
-		if (i == SLOT_PRIMARY)
+		if (i == Legacy::SLOT_PRIMARY)
 			TimerToUse = &attack_timer;
-		else if (i == SLOT_RANGE)
+		else if (i == Legacy::SLOT_RANGE)
 			TimerToUse = &ranged_timer;
-		else if(i == SLOT_SECONDARY)
+		else if(i == Legacy::SLOT_SECONDARY)
 			TimerToUse = &attack_dw_timer;
 		else	//invalid slot (hands will always hit this)
 			continue;
@@ -9023,7 +9023,7 @@ void Bot::SetAttackTimer() {
 			ItemToUse = ci->GetItem();
 
 		//special offhand stuff
-		if(i == SLOT_SECONDARY) {
+		if(i == Legacy::SLOT_SECONDARY) {
 			//if we have a 2H weapon in our main hand, no dual
 			if(PrimaryWeapon != nullptr) {
 				if(	PrimaryWeapon->ItemClass == ItemClassCommon
@@ -9117,7 +9117,7 @@ void Bot::SetAttackTimer() {
 			TimerToUse->SetAtTrigger(speed, true);
 		}
 
-		if(i == SLOT_PRIMARY)
+		if(i == Legacy::SLOT_PRIMARY)
 			PrimaryWeapon = ItemToUse;
 	}
 }
@@ -11608,10 +11608,10 @@ bool Bot::CheckLoreConflict(const Item_Struct* item) {
 		return false;
 
 	if (item->LoreGroup == -1)	// Standard lore items; look everywhere except the shared bank, return the result
-		return (m_inv.HasItem(item->ID, 0, invWhereWorn) != SLOT_INVALID);
+		return (m_inv.HasItem(item->ID, 0, invWhereWorn) != Legacy::SLOT_INVALID);
 
 	//If the item has a lore group, we check for other items with the same group and return the result
-	return (m_inv.HasItemByLoreGroup(item->LoreGroup, invWhereWorn) != SLOT_INVALID);
+	return (m_inv.HasItemByLoreGroup(item->LoreGroup, invWhereWorn) != Legacy::SLOT_INVALID);
 }
 
 bool Bot::GroupHasClass(Group* group, uint8 classId) {
@@ -12374,7 +12374,7 @@ void Bot::ProcessBotCommands(Client *c, const Seperator *sep) {
 				if(itm) {
 					c->PushItemOnCursor(*itminst, true);
 					Bot *gearbot = c->GetTarget()->CastToBot();
-					if((slotId == SLOT_RANGE)||(slotId == SLOT_AMMO)||(slotId == SLOT_PRIMARY)||(slotId == SLOT_SECONDARY)) {
+					if((slotId == Legacy::SLOT_RANGE)||(slotId == Legacy::SLOT_AMMO)||(slotId == Legacy::SLOT_PRIMARY)||(slotId == Legacy::SLOT_SECONDARY)) {
 						gearbot->SetBotArcher(false);
 					}
 					gearbot->RemoveBotItemBySlot(slotId, &TempErrorMessage);
@@ -16331,8 +16331,8 @@ void EntityList::BotPickLock(Bot* rogue)
 			curdist += (tmp * tmp);
 			if((zdiff < 10) && (curdist <= 130)) {
 				// All rogue items with lock pick bonuses are hands or primary
-				const ItemInst* item1 = rogue->GetBotItem(SLOT_HANDS);
-				const ItemInst* item2 = rogue->GetBotItem(SLOT_PRIMARY);
+				const ItemInst* item1 = rogue->GetBotItem(Legacy::SLOT_HANDS);
+				const ItemInst* item2 = rogue->GetBotItem(Legacy::SLOT_PRIMARY);
 
 				float bonus1 = 0.0f;
 				float bonus2 = 0.0f;
@@ -16566,7 +16566,7 @@ int Bot::GetRawACNoShield(int &shield_ac)
 {
 	int ac = itembonuses.AC + spellbonuses.AC;
 	shield_ac = 0;
-	ItemInst* inst = GetBotItem(SLOT_SECONDARY);
+	ItemInst* inst = GetBotItem(Legacy::SLOT_SECONDARY);
 	if(inst)
 	{
 		if(inst->GetItem()->ItemType == ItemTypeShield)
diff --git a/zone/client.cpp b/zone/client.cpp
index 0f814b3..7ad3b4c 100644
--- a/zone/client.cpp
+++ b/zone/client.cpp
@@ -1864,52 +1864,52 @@ void Client::FillSpawnStruct(NewSpawn_Struct* ns, Mob* ForWho)
 	// (update: i think pp should do it, as this holds LoY dye - plus, this is ugly code with Inventory!)
 	const Item_Struct* item = nullptr;
 	const ItemInst* inst = nullptr;
-	if ((inst = m_inv[SLOT_HANDS]) && inst->IsType(ItemClassCommon)) {
+	if ((inst = m_inv[Legacy::SLOT_HANDS]) && inst->IsType(ItemClassCommon)) {
 		item = inst->GetItem();
 		ns->spawn.equipment[MaterialHands]	= item->Material;
 		ns->spawn.colors[MaterialHands].color	= GetEquipmentColor(MaterialHands);
 	}
-	if ((inst = m_inv[SLOT_HEAD]) && inst->IsType(ItemClassCommon)) {
+	if ((inst = m_inv[Legacy::SLOT_HEAD]) && inst->IsType(ItemClassCommon)) {
 		item = inst->GetItem();
 		ns->spawn.equipment[MaterialHead]	= item->Material;
 		ns->spawn.colors[MaterialHead].color	= GetEquipmentColor(MaterialHead);
 	}
-	if ((inst = m_inv[SLOT_ARMS]) && inst->IsType(ItemClassCommon)) {
+	if ((inst = m_inv[Legacy::SLOT_ARMS]) && inst->IsType(ItemClassCommon)) {
 		item = inst->GetItem();
 		ns->spawn.equipment[MaterialArms]	= item->Material;
 		ns->spawn.colors[MaterialArms].color	= GetEquipmentColor(MaterialArms);
 	}
-	if ((inst = m_inv[SLOT_BRACER01]) && inst->IsType(ItemClassCommon)) {
+	if ((inst = m_inv[Legacy::SLOT_BRACER01]) && inst->IsType(ItemClassCommon)) {
 		item = inst->GetItem();
 		ns->spawn.equipment[MaterialWrist]= item->Material;
 		ns->spawn.colors[MaterialWrist].color	= GetEquipmentColor(MaterialWrist);
 	}
-	if ((inst = m_inv[SLOT_BRACER02]) && inst->IsType(ItemClassCommon)) {
+	if ((inst = m_inv[Legacy::SLOT_BRACER02]) && inst->IsType(ItemClassCommon)) {
 		item = inst->GetItem();
 		ns->spawn.equipment[MaterialWrist]= item->Material;
 		ns->spawn.colors[MaterialWrist].color	= GetEquipmentColor(MaterialWrist);
 	}
-	if ((inst = m_inv[SLOT_CHEST]) && inst->IsType(ItemClassCommon)) {
+	if ((inst = m_inv[Legacy::SLOT_CHEST]) && inst->IsType(ItemClassCommon)) {
 		item = inst->GetItem();
 		ns->spawn.equipment[MaterialChest]	= item->Material;
 		ns->spawn.colors[MaterialChest].color	= GetEquipmentColor(MaterialChest);
 	}
-	if ((inst = m_inv[SLOT_LEGS]) && inst->IsType(ItemClassCommon)) {
+	if ((inst = m_inv[Legacy::SLOT_LEGS]) && inst->IsType(ItemClassCommon)) {
 		item = inst->GetItem();
 		ns->spawn.equipment[MaterialLegs]	= item->Material;
 		ns->spawn.colors[MaterialLegs].color	= GetEquipmentColor(MaterialLegs);
 	}
-	if ((inst = m_inv[SLOT_FEET]) && inst->IsType(ItemClassCommon)) {
+	if ((inst = m_inv[Legacy::SLOT_FEET]) && inst->IsType(ItemClassCommon)) {
 		item = inst->GetItem();
 		ns->spawn.equipment[MaterialFeet]	= item->Material;
 		ns->spawn.colors[MaterialFeet].color	= GetEquipmentColor(MaterialFeet);
 	}
-	if ((inst = m_inv[SLOT_PRIMARY]) && inst->IsType(ItemClassCommon)) {
+	if ((inst = m_inv[Legacy::SLOT_PRIMARY]) && inst->IsType(ItemClassCommon)) {
 		item = inst->GetItem();
 		if (strlen(item->IDFile) > 2)
 			ns->spawn.equipment[MaterialPrimary] = atoi(&item->IDFile[2]);
 	}
-	if ((inst = m_inv[SLOT_SECONDARY]) && inst->IsType(ItemClassCommon)) {
+	if ((inst = m_inv[Legacy::SLOT_SECONDARY]) && inst->IsType(ItemClassCommon)) {
 		item = inst->GetItem();
 		if (strlen(item->IDFile) > 2)
 			ns->spawn.equipment[MaterialSecondary] = atoi(&item->IDFile[2]);
@@ -2615,7 +2615,7 @@ bool Client::BindWound(Mob* bindmob, bool start, bool fail){
 		if(!bindwound_timer.Enabled()) {
 			//make sure we actually have a bandage... and consume it.
 			int16 bslot = m_inv.HasItemByUse(ItemTypeBandage, 1, invWhereWorn|invWherePersonal);
-			if(bslot == SLOT_INVALID) {
+			if(bslot == Legacy::SLOT_INVALID) {
 				bind_out->type = 3;
 				QueuePacket(outapp);
 				bind_out->type = 7;	//this is the wrong message, dont know the right one.
@@ -2769,25 +2769,25 @@ bool Client::BindWound(Mob* bindmob, bool start, bool fail){
 void Client::SetMaterial(int16 in_slot, uint32 item_id){
 	const Item_Struct* item = database.GetItem(item_id);
 	if (item && (item->ItemClass==ItemClassCommon)) {
-		if (in_slot==SLOT_HEAD)
+		if (in_slot==Legacy::SLOT_HEAD)
 			m_pp.item_material[MaterialHead]		= item->Material;
-		else if (in_slot==SLOT_CHEST)
+		else if (in_slot==Legacy::SLOT_CHEST)
 			m_pp.item_material[MaterialChest]		= item->Material;
-		else if (in_slot==SLOT_ARMS)
+		else if (in_slot==Legacy::SLOT_ARMS)
 			m_pp.item_material[MaterialArms]		= item->Material;
-		else if (in_slot==SLOT_BRACER01)
+		else if (in_slot==Legacy::SLOT_BRACER01)
 			m_pp.item_material[MaterialWrist]		= item->Material;
-		else if (in_slot==SLOT_BRACER02)
+		else if (in_slot==Legacy::SLOT_BRACER02)
 			m_pp.item_material[MaterialWrist]		= item->Material;
-		else if (in_slot==SLOT_HANDS)
+		else if (in_slot==Legacy::SLOT_HANDS)
 			m_pp.item_material[MaterialHands]		= item->Material;
-		else if (in_slot==SLOT_LEGS)
+		else if (in_slot==Legacy::SLOT_LEGS)
 			m_pp.item_material[MaterialLegs]		= item->Material;
-		else if (in_slot==SLOT_FEET)
+		else if (in_slot==Legacy::SLOT_FEET)
 			m_pp.item_material[MaterialFeet]		= item->Material;
-		else if (in_slot==SLOT_PRIMARY)
+		else if (in_slot==Legacy::SLOT_PRIMARY)
 			m_pp.item_material[MaterialPrimary]	= atoi(item->IDFile+2);
-		else if (in_slot==SLOT_SECONDARY)
+		else if (in_slot==Legacy::SLOT_SECONDARY)
 			m_pp.item_material[MaterialSecondary]	= atoi(item->IDFile+2);
 	}
 }
@@ -2970,25 +2970,25 @@ void Client::SetTint(int16 in_slot, uint32 color) {
 
 // Still need to reconcile bracer01 versus bracer02
 void Client::SetTint(int16 in_slot, Color_Struct& color) {
-	if (in_slot==SLOT_HEAD)
+	if (in_slot==Legacy::SLOT_HEAD)
 		m_pp.item_tint[MaterialHead].color=color.color;
-	else if (in_slot==SLOT_ARMS)
+	else if (in_slot==Legacy::SLOT_ARMS)
 		m_pp.item_tint[MaterialArms].color=color.color;
-	else if (in_slot==SLOT_BRACER01)
+	else if (in_slot==Legacy::SLOT_BRACER01)
 		m_pp.item_tint[MaterialWrist].color=color.color;
-	else if (in_slot==SLOT_BRACER02)
+	else if (in_slot==Legacy::SLOT_BRACER02)
 		m_pp.item_tint[MaterialWrist].color=color.color;
-	else if (in_slot==SLOT_HANDS)
+	else if (in_slot==Legacy::SLOT_HANDS)
 		m_pp.item_tint[MaterialHands].color=color.color;
-	else if (in_slot==SLOT_PRIMARY)
+	else if (in_slot==Legacy::SLOT_PRIMARY)
 		m_pp.item_tint[MaterialPrimary].color=color.color;
-	else if (in_slot==SLOT_SECONDARY)
+	else if (in_slot==Legacy::SLOT_SECONDARY)
 		m_pp.item_tint[MaterialSecondary].color=color.color;
-	else if (in_slot==SLOT_CHEST)
+	else if (in_slot==Legacy::SLOT_CHEST)
 		m_pp.item_tint[MaterialChest].color=color.color;
-	else if (in_slot==SLOT_LEGS)
+	else if (in_slot==Legacy::SLOT_LEGS)
 		m_pp.item_tint[MaterialLegs].color=color.color;
-	else if (in_slot==SLOT_FEET)
+	else if (in_slot==Legacy::SLOT_FEET)
 		m_pp.item_tint[MaterialFeet].color=color.color;
 }
 
@@ -3056,28 +3056,28 @@ void Client::LinkDead()
 uint8 Client::SlotConvert(uint8 slot,bool bracer){
 	uint8 slot2=0;
 	if(bracer)
-		return SLOT_BRACER02;
+		return Legacy::SLOT_BRACER02;
 	switch(slot){
 		case MaterialHead:
-			slot2=SLOT_HEAD;
+			slot2=Legacy::SLOT_HEAD;
 			break;
 		case MaterialChest:
-			slot2=SLOT_CHEST;
+			slot2=Legacy::SLOT_CHEST;
 			break;
 		case MaterialArms:
-			slot2=SLOT_ARMS;
+			slot2=Legacy::SLOT_ARMS;
 			break;
 		case MaterialWrist:
-			slot2=SLOT_BRACER01;
+			slot2=Legacy::SLOT_BRACER01;
 			break;
 		case MaterialHands:
-			slot2=SLOT_HANDS;
+			slot2=Legacy::SLOT_HANDS;
 			break;
 		case MaterialLegs:
-			slot2=SLOT_LEGS;
+			slot2=Legacy::SLOT_LEGS;
 			break;
 		case MaterialFeet:
-			slot2=SLOT_FEET;
+			slot2=Legacy::SLOT_FEET;
 			break;
 		}
 	return slot2;
@@ -3086,25 +3086,25 @@ uint8 Client::SlotConvert(uint8 slot,bool bracer){
 uint8 Client::SlotConvert2(uint8 slot){
 	uint8 slot2=0;
 	switch(slot){
-		case SLOT_HEAD:
+		case Legacy::SLOT_HEAD:
 			slot2=MaterialHead;
 			break;
-		case SLOT_CHEST:
+		case Legacy::SLOT_CHEST:
 			slot2=MaterialChest;
 			break;
-		case SLOT_ARMS:
+		case Legacy::SLOT_ARMS:
 			slot2=MaterialArms;
 			break;
-		case SLOT_BRACER01:
+		case Legacy::SLOT_BRACER01:
 			slot2=MaterialWrist;
 			break;
-		case SLOT_HANDS:
+		case Legacy::SLOT_HANDS:
 			slot2=MaterialHands;
 			break;
-		case SLOT_LEGS:
+		case Legacy::SLOT_LEGS:
 			slot2=MaterialLegs;
 			break;
-		case SLOT_FEET:
+		case Legacy::SLOT_FEET:
 			slot2=MaterialFeet;
 			break;
 		}
diff --git a/zone/client.h b/zone/client.h
index b26987e..aad1f88 100644
--- a/zone/client.h
+++ b/zone/client.h
@@ -787,7 +787,7 @@ public:
 	void	QSSwapItemAuditor(MoveItem_Struct* move_in, bool postaction_call = false);
 	void	PutLootInInventory(int16 slot_id, const ItemInst &inst, ServerLootItem_Struct** bag_item_data = 0);
 	bool	AutoPutLootInInventory(ItemInst& inst, bool try_worn = false, bool try_cursor = true, ServerLootItem_Struct** bag_item_data = 0);
-	void	SummonItem(uint32 item_id, int16 charges = -1, uint32 aug1=0, uint32 aug2=0, uint32 aug3=0, uint32 aug4=0, uint32 aug5=0, bool attuned=false, uint16 to_slot=SLOT_CURSOR);
+	void	SummonItem(uint32 item_id, int16 charges = -1, uint32 aug1=0, uint32 aug2=0, uint32 aug3=0, uint32 aug4=0, uint32 aug5=0, bool attuned=false, uint16 to_slot=Legacy::SLOT_CURSOR);
 	void	SetStats(uint8 type,int16 set_val);
 	void	IncStats(uint8 type,int16 increase_val);
 	void	DropItem(int16 slot_id);
diff --git a/zone/client_mods.cpp b/zone/client_mods.cpp
index 925aa15..114d78e 100644
--- a/zone/client_mods.cpp
+++ b/zone/client_mods.cpp
@@ -1969,7 +1969,7 @@ int Client::GetRawACNoShield(int &shield_ac) const
 {
 	int ac = itembonuses.AC + spellbonuses.AC;
 	shield_ac = 0;
-	const ItemInst *inst = m_inv.GetItem(SLOT_SECONDARY);
+	const ItemInst *inst = m_inv.GetItem(Legacy::SLOT_SECONDARY);
 	if(inst)
 	{
 		if(inst->GetItem()->ItemType == ItemTypeShield)
diff --git a/zone/client_packet.cpp b/zone/client_packet.cpp
index 6d8715c..26188fa 100644
--- a/zone/client_packet.cpp
+++ b/zone/client_packet.cpp
@@ -2452,7 +2452,7 @@ void Client::Handle_OP_AdventureMerchantPurchase(const EQApplicationPacket *app)
 	ItemInst *inst = database.CreateItem(item, charges);
 	if(!AutoPutLootInInventory(*inst, true, true))
 	{
-		PutLootInInventory(SLOT_CURSOR, *inst);
+		PutLootInInventory(Legacy::SLOT_CURSOR, *inst);
 	}
 	Save(1);
 }
@@ -3276,20 +3276,20 @@ void Client::Handle_OP_MoveItem(const EQApplicationPacket *app)
 	if(mi->from_slot >= 251 && mi->from_slot <= 340) {
 		if(mi->from_slot > 330) { mi_hack = true; }
 		else {
-			int16 from_parent = m_inv.CalcSlotId(mi->from_slot);
+			int16 from_parent = Legacy::CalcSlotId(mi->from_slot);
 			if(!m_inv[from_parent]) { mi_hack = true; }
 			else if(!m_inv[from_parent]->IsType(ItemClassContainer)) { mi_hack = true; }
-			else if(m_inv.CalcBagIdx(mi->from_slot) >= m_inv[from_parent]->GetItem()->BagSlots) { mi_hack = true; }
+			else if(Legacy::CalcBagIdx(mi->from_slot) >= m_inv[from_parent]->GetItem()->BagSlots) { mi_hack = true; }
 		}
 	}
 
 	if(mi->to_slot >= 251 && mi->to_slot <= 340) {
 		if(mi->to_slot > 330) { mi_hack = true; }
 		else {
-			int16 to_parent = m_inv.CalcSlotId(mi->to_slot);
+			int16 to_parent = Legacy::CalcSlotId(mi->to_slot);
 			if(!m_inv[to_parent]) { mi_hack = true; }
 			else if(!m_inv[to_parent]->IsType(ItemClassContainer)) { mi_hack = true; }
-			else if(m_inv.CalcBagIdx(mi->to_slot) >= m_inv[to_parent]->GetItem()->BagSlots) { mi_hack = true; }
+			else if(Legacy::CalcBagIdx(mi->to_slot) >= m_inv[to_parent]->GetItem()->BagSlots) { mi_hack = true; }
 		}
 	}
 
@@ -5609,8 +5609,8 @@ void Client::Handle_OP_ShopPlayerBuy(const EQApplicationPacket *app)
 		freeslotid = m_inv.FindFreeSlot(false, true, item->Size);
 
 	//make sure we are not completely full...
-	if(freeslotid == SLOT_CURSOR) {
-		if(m_inv.GetItem(SLOT_CURSOR) != nullptr) {
+	if(freeslotid == Legacy::SLOT_CURSOR) {
+		if(m_inv.GetItem(Legacy::SLOT_CURSOR) != nullptr) {
 			Message(13, "You do not have room for any more items.");
 			safe_delete(outapp);
 			safe_delete(inst);
@@ -5618,7 +5618,7 @@ void Client::Handle_OP_ShopPlayerBuy(const EQApplicationPacket *app)
 		}
 	}
 
-	if(freeslotid == SLOT_INVALID)
+	if(freeslotid == Legacy::SLOT_INVALID)
 	{
 		Message(13, "You do not have room for any more items.");
 		safe_delete(outapp);
@@ -6205,7 +6205,7 @@ void Client::Handle_OP_ClickDoor(const EQApplicationPacket *app)
 
 void Client::Handle_OP_CreateObject(const EQApplicationPacket *app)
 {
-	DropItem(SLOT_CURSOR);
+	DropItem(Legacy::SLOT_CURSOR);
 	return;
 }
 
@@ -9225,7 +9225,7 @@ bool Client::FinishConnState2(DBAsyncWork* dbaw) {
 			if (it==m_inv.cursor_begin())
 				continue;
 			const ItemInst *inst=*it;
-			SendItemPacket(SLOT_CURSOR, inst, ItemPacketSummonItem);
+			SendItemPacket(Legacy::SLOT_CURSOR, inst, ItemPacketSummonItem);
 		}
 	}
 
@@ -11036,8 +11036,8 @@ void Client::Handle_OP_ApplyPoison(const EQApplicationPacket *app) {
 	}
 	uint32 ApplyPoisonSuccessResult = 0;
 	ApplyPoison_Struct* ApplyPoisonData = (ApplyPoison_Struct*)app->pBuffer;
-	const ItemInst* PrimaryWeapon = GetInv().GetItem(SLOT_PRIMARY);
-	const ItemInst* SecondaryWeapon = GetInv().GetItem(SLOT_SECONDARY);
+	const ItemInst* PrimaryWeapon = GetInv().GetItem(Legacy::SLOT_PRIMARY);
+	const ItemInst* SecondaryWeapon = GetInv().GetItem(Legacy::SLOT_SECONDARY);
 	const ItemInst* PoisonItemInstance = GetInv()[ApplyPoisonData->inventorySlot];
 
 	bool IsPoison = PoisonItemInstance && (PoisonItemInstance->GetItem()->ItemType == ItemTypePoison);
@@ -11820,7 +11820,7 @@ void Client::Handle_OP_GuildBank(const EQApplicationPacket *app)
 				return;
 			}
 
-			ItemInst *CursorItemInst = GetInv().GetItem(SLOT_CURSOR);
+			ItemInst *CursorItemInst = GetInv().GetItem(Legacy::SLOT_CURSOR);
 
 			bool Allowed = true;
 
@@ -11877,7 +11877,7 @@ void Client::Handle_OP_GuildBank(const EQApplicationPacket *app)
 			{
 				GuildBankDepositAck(false);
 
-				DeleteItemInInventory(SLOT_CURSOR, 0, false);
+				DeleteItemInInventory(Legacy::SLOT_CURSOR, 0, false);
 			}
 
 			break;
@@ -11898,7 +11898,7 @@ void Client::Handle_OP_GuildBank(const EQApplicationPacket *app)
 
 		case GuildBankWithdraw:
 		{
-			if(GetInv()[SLOT_CURSOR])
+			if(GetInv()[Legacy::SLOT_CURSOR])
 			{
 				Message_StringID(13, GUILD_BANK_EMPTY_HANDS);
 
@@ -11944,7 +11944,7 @@ void Client::Handle_OP_GuildBank(const EQApplicationPacket *app)
 			{
 				PushItemOnCursor(*inst);
 
-				SendItemPacket(SLOT_CURSOR, inst, ItemPacketSummonItem);
+				SendItemPacket(Legacy::SLOT_CURSOR, inst, ItemPacketSummonItem);
 
 				GuildBanks->DeleteItem(GuildID(), gbwis->Area, gbwis->SlotID, gbwis->Quantity);
 			}
@@ -12735,7 +12735,7 @@ void Client::Handle_OP_AltCurrencyPurchase(const EQApplicationPacket *app) {
 		ItemInst *inst = database.CreateItem(item, charges);
 		if(!AutoPutLootInInventory(*inst, true, true))
 		{
-			PutLootInInventory(SLOT_CURSOR, *inst);
+			PutLootInInventory(Legacy::SLOT_CURSOR, *inst);
 		}
 
 		Save(1);
@@ -12769,7 +12769,7 @@ void Client::Handle_OP_AltCurrencyReclaim(const EQApplicationPacket *app) {
 			SummonItem(item_id, max_currency);
 			SetAlternateCurrencyValue(reclaim->currency_id, 0);
 		} else {
-			SummonItem(item_id, reclaim->count, 0, 0, 0, 0, 0, false, SLOT_CURSOR);
+			SummonItem(item_id, reclaim->count, 0, 0, 0, 0, 0, false, Legacy::SLOT_CURSOR);
 			AddAlternateCurrencyValue(reclaim->currency_id, -((int32)reclaim->count));
 		}
 	}
diff --git a/zone/client_process.cpp b/zone/client_process.cpp
index 4bebec6..5cbcdb5 100644
--- a/zone/client_process.cpp
+++ b/zone/client_process.cpp
@@ -293,7 +293,7 @@ bool Client::Process() {
 		}
 
 		if(AutoFireEnabled()){
-			ItemInst *ranged = GetInv().GetItem(SLOT_RANGE);
+			ItemInst *ranged = GetInv().GetItem(Legacy::SLOT_RANGE);
 			if(ranged)
 			{
 				if(ranged->GetItem() && ranged->GetItem()->ItemType == ItemTypeBow){
@@ -404,7 +404,7 @@ bool Client::Process() {
 				} else {
 					Attack(auto_attack_target, 13); // Kaiyodo - added attacking hand to arguments
 				}
-				ItemInst *wpn = GetInv().GetItem(SLOT_PRIMARY);
+				ItemInst *wpn = GetInv().GetItem(Legacy::SLOT_PRIMARY);
 				TryWeaponProc(wpn, auto_attack_target, 13);
 
 				bool tripleAttackSuccess = false;
@@ -452,7 +452,7 @@ bool Client::Process() {
 				int16 ExtraAttackChanceBonus = spellbonuses.ExtraAttackChance + itembonuses.ExtraAttackChance + aabonuses.ExtraAttackChance;
 
 				if (auto_attack_target && ExtraAttackChanceBonus) {
-					ItemInst *wpn = GetInv().GetItem(SLOT_PRIMARY);
+					ItemInst *wpn = GetInv().GetItem(Legacy::SLOT_PRIMARY);
 					if(wpn){
 						if(wpn->GetItem()->ItemType == ItemType2HSlash ||
 							wpn->GetItem()->ItemType == ItemType2HBlunt ||
@@ -511,7 +511,7 @@ bool Client::Process() {
 					} else {
 						Attack(auto_attack_target, 14);	// Single attack with offhand
 					}
-					ItemInst *wpn = GetInv().GetItem(SLOT_SECONDARY);
+					ItemInst *wpn = GetInv().GetItem(Legacy::SLOT_SECONDARY);
 					TryWeaponProc(wpn, auto_attack_target, 14);
 
 					if( CanThisClassDoubleAttack() && CheckDoubleAttack()) {
@@ -1213,7 +1213,7 @@ void Client::OPMemorizeSpell(const EQApplicationPacket* app)
 	switch(memspell->scribing)
 	{
 		case memSpellScribing:	{	// scribing spell to book
-			const ItemInst* inst = m_inv[SLOT_CURSOR];
+			const ItemInst* inst = m_inv[Legacy::SLOT_CURSOR];
 
 			if(inst && inst->IsType(ItemClassCommon))
 			{
@@ -1222,7 +1222,7 @@ void Client::OPMemorizeSpell(const EQApplicationPacket* app)
 				if(item && item->Scroll.Effect == (int32)(memspell->spell_id))
 				{
 					ScribeSpell(memspell->spell_id, memspell->slot);
-					DeleteItemInInventory(SLOT_CURSOR, 1, true);
+					DeleteItemInInventory(Legacy::SLOT_CURSOR, 1, true);
 				}
 				else
 					Message(0,"Scribing spell: inst exists but item does not or spell ids do not match.");
diff --git a/zone/command.cpp b/zone/command.cpp
index 35f2926..7271398 100644
--- a/zone/command.cpp
+++ b/zone/command.cpp
@@ -2913,7 +2913,7 @@ void command_peekinv(Client *c, const Seperator *sep)
 					if (c->GetClientVersion() >= EQClientSoF)
 					{
 						c->Message((item==0), "   InvBagSlot: %i (Slot #%i, Bag #%i), Item: %i (%c%06X00000000000000000000000000000000000000000000%s%c), Charges: %i",
-							Inventory::CalcSlotId(i, j),
+							Legacy::CalcSlotId(i, j),
 							i, j, ((item==0)?0:item->ID),0x12, ((item==0)?0:item->ID),
 							((item==0)?"null":item->Name), 0x12,
 							((item==0)?0:instbag->GetCharges()));
@@ -2921,7 +2921,7 @@ void command_peekinv(Client *c, const Seperator *sep)
 					else
 					{
 						c->Message((item==0), "   InvBagSlot: %i (Slot #%i, Bag #%i), Item: %i (%c%06X000000000000000000000000000000000000000%s%c), Charges: %i",
-							Inventory::CalcSlotId(i, j),
+							Legacy::CalcSlotId(i, j),
 							i, j, ((item==0)?0:item->ID),0x12, ((item==0)?0:item->ID),
 							((item==0)?"null":item->Name), 0x12,
 							((item==0)?0:instbag->GetCharges()));
@@ -2951,12 +2951,12 @@ void command_peekinv(Client *c, const Seperator *sep)
 		if(client->GetInv().CursorEmpty()) { // Display 'front' cursor slot even if 'empty' (item(30[0]) == null)
 			if (c->GetClientVersion() >= EQClientSoF)
 			{
-				c->Message((item==0), "CursorSlot: %i, Depth: %i, Item: %i (%c%06X00000000000000000000000000000000000000000000%s%c), Charges: %i", SLOT_CURSOR,i,
+				c->Message((item==0), "CursorSlot: %i, Depth: %i, Item: %i (%c%06X00000000000000000000000000000000000000000000%s%c), Charges: %i", Legacy::SLOT_CURSOR,i,
 					0, 0x12, 0, "null", 0x12, 0);
 			}
 			else
 			{
-				c->Message((item==0), "CursorSlot: %i, Depth: %i, Item: %i (%c%06X000000000000000000000000000000000000000%s%c), Charges: %i", SLOT_CURSOR,i,
+				c->Message((item==0), "CursorSlot: %i, Depth: %i, Item: %i (%c%06X000000000000000000000000000000000000000%s%c), Charges: %i", Legacy::SLOT_CURSOR,i,
 					0, 0x12, 0, "null", 0x12, 0);
 			}
 		}
@@ -2966,14 +2966,14 @@ void command_peekinv(Client *c, const Seperator *sep)
 				item = (inst) ? inst->GetItem() : nullptr;
 				if (c->GetClientVersion() >= EQClientSoF)
 				{
-					c->Message((item==0), "CursorSlot: %i, Depth: %i, Item: %i (%c%06X00000000000000000000000000000000000000000000%s%c), Charges: %i", SLOT_CURSOR,i,
+					c->Message((item==0), "CursorSlot: %i, Depth: %i, Item: %i (%c%06X00000000000000000000000000000000000000000000%s%c), Charges: %i", Legacy::SLOT_CURSOR,i,
 						((item==0)?0:item->ID),0x12, ((item==0)?0:item->ID),
 						((item==0)?"null":item->Name), 0x12,
 						((item==0)?0:inst->GetCharges()));
 				}
 				else
 				{
-					c->Message((item==0), "CursorSlot: %i, Depth: %i, Item: %i (%c%06X000000000000000000000000000000000000000%s%c), Charges: %i", SLOT_CURSOR,i,
+					c->Message((item==0), "CursorSlot: %i, Depth: %i, Item: %i (%c%06X000000000000000000000000000000000000000%s%c), Charges: %i", Legacy::SLOT_CURSOR,i,
 						((item==0)?0:item->ID),0x12, ((item==0)?0:item->ID),
 						((item==0)?"null":item->Name), 0x12,
 						((item==0)?0:inst->GetCharges()));
@@ -2981,21 +2981,21 @@ void command_peekinv(Client *c, const Seperator *sep)
 
 				if (inst && inst->IsType(ItemClassContainer) && i==0) { // 'CSD 1' - only display contents of slot 30[0] container..higher ones don't exist
 					for (uint8 j=0; j<10; j++) {
-						const ItemInst* instbag = client->GetInv().GetItem(SLOT_CURSOR, j);
+						const ItemInst* instbag = client->GetInv().GetItem(Legacy::SLOT_CURSOR, j);
 						item = (instbag) ? instbag->GetItem() : nullptr;
 						if (c->GetClientVersion() >= EQClientSoF)
 						{
 							c->Message((item==0), "   CursorBagSlot: %i (Slot #%i, Bag #%i), Item: %i (%c%06X00000000000000000000000000000000000000000000%s%c), Charges: %i",
-								Inventory::CalcSlotId(SLOT_CURSOR, j),
-								SLOT_CURSOR, j, ((item==0)?0:item->ID),0x12, ((item==0)?0:item->ID),
+								Legacy::CalcSlotId(Legacy::SLOT_CURSOR, j),
+								Legacy::SLOT_CURSOR, j, ((item==0)?0:item->ID),0x12, ((item==0)?0:item->ID),
 								((item==0)?"null":item->Name), 0x12,
 								((item==0)?0:instbag->GetCharges()));
 						}
 						else
 						{
 							c->Message((item==0), "   CursorBagSlot: %i (Slot #%i, Bag #%i), Item: %i (%c%06X000000000000000000000000000000000000000%s%c), Charges: %i",
-								Inventory::CalcSlotId(SLOT_CURSOR, j),
-								SLOT_CURSOR, j, ((item==0)?0:item->ID),0x12, ((item==0)?0:item->ID),
+								Legacy::CalcSlotId(Legacy::SLOT_CURSOR, j),
+								Legacy::SLOT_CURSOR, j, ((item==0)?0:item->ID),0x12, ((item==0)?0:item->ID),
 								((item==0)?"null":item->Name), 0x12,
 								((item==0)?0:instbag->GetCharges()));
 						}
@@ -3057,7 +3057,7 @@ void command_peekinv(Client *c, const Seperator *sep)
 					if (c->GetClientVersion() >= EQClientSoF)
 					{
 						c->Message((item==0), "   BankBagSlot: %i (Slot #%i, Bag #%i), Item: %i (%c%06X00000000000000000000000000000000000000000000%s%c), Charges: %i",
-							Inventory::CalcSlotId(i, j),
+							Legacy::CalcSlotId(i, j),
 							i, j, ((item==0)?0:item->ID),0x12, ((item==0)?0:item->ID),
 							((item==0)?"null":item->Name), 0x12,
 							((item==0)?0:inst->GetCharges()));
@@ -3065,7 +3065,7 @@ void command_peekinv(Client *c, const Seperator *sep)
 					else
 					{
 						c->Message((item==0), "   BankBagSlot: %i (Slot #%i, Bag #%i), Item: %i (%c%06X000000000000000000000000000000000000000%s%c), Charges: %i",
-							Inventory::CalcSlotId(i, j),
+							Legacy::CalcSlotId(i, j),
 							i, j, ((item==0)?0:item->ID),0x12, ((item==0)?0:item->ID),
 							((item==0)?"null":item->Name), 0x12,
 							((item==0)?0:inst->GetCharges()));
@@ -3098,7 +3098,7 @@ void command_peekinv(Client *c, const Seperator *sep)
 					if (c->GetClientVersion() >= EQClientSoF)
 					{
 						c->Message((item==0), "   ShBankBagSlot: %i (Slot #%i, Bag #%i), Item: %i (%c%06X00000000000000000000000000000000000000000000%s%c), Charges: %i",
-							Inventory::CalcSlotId(i, j),
+							Legacy::CalcSlotId(i, j),
 							i, j, ((item==0)?0:item->ID),0x12, ((item==0)?0:item->ID),
 							((item==0)?"null":item->Name), 0x12,
 							((item==0)?0:inst->GetCharges()));
@@ -3106,7 +3106,7 @@ void command_peekinv(Client *c, const Seperator *sep)
 					else
 					{
 						c->Message((item==0), "   ShBankBagSlot: %i (Slot #%i, Bag #%i), Item: %i (%c%06X000000000000000000000000000000000000000%s%c), Charges: %i",
-							Inventory::CalcSlotId(i, j),
+							Legacy::CalcSlotId(i, j),
 							i, j, ((item==0)?0:item->ID),0x12, ((item==0)?0:item->ID),
 							((item==0)?"null":item->Name), 0x12,
 							((item==0)?0:inst->GetCharges()));
@@ -3143,7 +3143,7 @@ void command_peekinv(Client *c, const Seperator *sep)
 					if (c->GetClientVersion() >= EQClientSoF)
 					{
 						c->Message((item==0), "   TradeBagSlot: %i (Slot #%i, Bag #%i), Item: %i (%c%06X00000000000000000000000000000000000000000000%s%c), Charges: %i",
-							Inventory::CalcSlotId(i, j),
+							Legacy::CalcSlotId(i, j),
 							i, j, ((item==0)?0:item->ID),0x12, ((item==0)?0:item->ID),
 							((item==0)?"null":item->Name), 0x12,
 							((item==0)?0:inst->GetCharges()));
@@ -3151,7 +3151,7 @@ void command_peekinv(Client *c, const Seperator *sep)
 					else
 					{
 						c->Message((item==0), "   TradeBagSlot: %i (Slot #%i, Bag #%i), Item: %i (%c%06X000000000000000000000000000000000000000%s%c), Charges: %i",
-							Inventory::CalcSlotId(i, j),
+							Legacy::CalcSlotId(i, j),
 							i, j, ((item==0)?0:item->ID),0x12, ((item==0)?0:item->ID),
 							((item==0)?"null":item->Name), 0x12,
 							((item==0)?0:inst->GetCharges()));
@@ -3507,7 +3507,7 @@ void command_equipitem(Client *c, const Seperator *sep)
 {
 	uint32 slot_id = atoi(sep->arg[1]);
 	if (sep->IsNumber(1) && (slot_id>=0) && (slot_id<=21)) {
-		const ItemInst* from_inst = c->GetInv().GetItem(SLOT_CURSOR);
+		const ItemInst* from_inst = c->GetInv().GetItem(Legacy::SLOT_CURSOR);
 		const ItemInst* to_inst = c->GetInv().GetItem(slot_id); // added (desync issue when forcing stack to stack)
 		bool partialmove = false;
 		int16 movecount;
@@ -3515,7 +3515,7 @@ void command_equipitem(Client *c, const Seperator *sep)
 		if (from_inst && from_inst->IsType(ItemClassCommon)) {
 			EQApplicationPacket* outapp = new EQApplicationPacket(OP_MoveItem, sizeof(MoveItem_Struct));
 			MoveItem_Struct* mi	= (MoveItem_Struct*)outapp->pBuffer;
-			mi->from_slot		= SLOT_CURSOR;
+			mi->from_slot		= Legacy::SLOT_CURSOR;
 			mi->to_slot			= slot_id;
 			// mi->number_in_stack	= from_inst->GetCharges(); // replaced with con check for stacking
 
@@ -4672,7 +4672,7 @@ void command_goto(Client *c, const Seperator *sep)
 
 void command_iteminfo(Client *c, const Seperator *sep)
 {
-	const ItemInst* inst = c->GetInv()[SLOT_CURSOR];
+	const ItemInst* inst = c->GetInv()[Legacy::SLOT_CURSOR];
 
 	if (!inst)
 		c->Message(13, "Error: You need an item on your cursor for this command");
diff --git a/zone/corpse.cpp b/zone/corpse.cpp
index 992649c..33637c7 100644
--- a/zone/corpse.cpp
+++ b/zone/corpse.cpp
@@ -421,7 +421,7 @@ Corpse::Corpse(Client* client, int32 in_rezexp)
 
 		if(cursor) { // all cursor items should be on corpse (client < SoF or RespawnFromHover = false)
 			while(!client->GetInv().CursorEmpty())
-				client->DeleteItemInInventory(SLOT_CURSOR, 0, false, false);
+				client->DeleteItemInInventory(Legacy::SLOT_CURSOR, 0, false, false);
 		}
 		else { // only visible cursor made it to corpse (client >= Sof and RespawnFromHover = true)
 			std::list<ItemInst*>::const_iterator start = client->GetInv().cursor_begin();
@@ -454,13 +454,13 @@ std::list<uint32> Corpse::MoveItemToCorpse(Client *client, ItemInst *item, int16
 		for(bagindex = 0; bagindex <= 9; bagindex++)
 		{
 			// For empty bags in cursor queue, slot was previously being resolved as SLOT_INVALID (-1)
-			interior_slot = Inventory::CalcSlotId(equipslot, bagindex);
+			interior_slot = Legacy::CalcSlotId(equipslot, bagindex);
 			interior_item = client->GetInv().GetItem(interior_slot);
 
 			if(interior_item)
 			{
 				AddItem(interior_item->GetItem()->ID, interior_item->GetCharges(), interior_slot, interior_item->GetAugmentItemID(0), interior_item->GetAugmentItemID(1), interior_item->GetAugmentItemID(2), interior_item->GetAugmentItemID(3), interior_item->GetAugmentItemID(4));
-				returnlist.push_back(Inventory::CalcSlotId(equipslot, bagindex));
+				returnlist.push_back(Legacy::CalcSlotId(equipslot, bagindex));
 				client->DeleteItemInInventory(interior_slot, 0, true, false);
 			}
 		}
@@ -685,7 +685,7 @@ ServerLootItem_Struct* Corpse::GetItem(uint16 lootslot, ServerLootItem_Struct**
 
 	if (sitem && bag_item_data && Inventory::SupportsContainers(sitem->equipSlot))
 	{
-		int16 bagstart = Inventory::CalcSlotId(sitem->equipSlot, 0);
+		int16 bagstart = Legacy::CalcSlotId(sitem->equipSlot, 0);
 
 		cur = itemlist.begin();
 		end = itemlist.end();
@@ -1227,11 +1227,11 @@ void Corpse::LootItem(Client* client, const EQApplicationPacket* app)
 		if(lootitem->auto_loot)
 		{
 			if(!client->AutoPutLootInInventory(*inst, true, true, bag_item_data))
-				client->PutLootInInventory(SLOT_CURSOR, *inst, bag_item_data);
+				client->PutLootInInventory(Legacy::SLOT_CURSOR, *inst, bag_item_data);
 		}
 		else
 		{
-			client->PutLootInInventory(SLOT_CURSOR, *inst, bag_item_data);
+			client->PutLootInInventory(Legacy::SLOT_CURSOR, *inst, bag_item_data);
 		}
 		// Update any tasks that have an activity to loot this item.
 		if(RuleB(TaskSystem, EnableTaskSystem))
diff --git a/zone/doors.cpp b/zone/doors.cpp
index 0d11206..640663c 100644
--- a/zone/doors.cpp
+++ b/zone/doors.cpp
@@ -162,7 +162,7 @@ void Doors::HandleClick(Client* sender, uint8 trigger)
 			{
 				if(!sender->KeyRingCheck(RuleI(Adventure, ItemIDToEnablePorts)))
 				{
-					if(sender->GetInv().HasItem(RuleI(Adventure, ItemIDToEnablePorts)) == SLOT_INVALID)
+					if(sender->GetInv().HasItem(RuleI(Adventure, ItemIDToEnablePorts)) == Legacy::SLOT_INVALID)
 					{
 						sender->Message_StringID(13, 5141);
 						safe_delete(outapp);
@@ -195,11 +195,11 @@ void Doors::HandleClick(Client* sender, uint8 trigger)
 	uint8 keepoffkeyring = GetNoKeyring();
 	uint32 haskey = 0;
 	uint32 playerkey = 0;
-	const ItemInst *lockpicks = sender->GetInv().GetItem(SLOT_CURSOR);
+	const ItemInst *lockpicks = sender->GetInv().GetItem(Legacy::SLOT_CURSOR);
 
 	haskey = sender->GetInv().HasItem(keyneeded, 1);
 
-	if(haskey != SLOT_INVALID)
+	if(haskey != Legacy::SLOT_INVALID)
 	{
 		playerkey = keyneeded;
 	}
diff --git a/zone/forage.cpp b/zone/forage.cpp
index ee0f45f..bf8d28e 100644
--- a/zone/forage.cpp
+++ b/zone/forage.cpp
@@ -206,10 +206,10 @@ uint32 ZoneDatabase::GetZoneFishing(uint32 ZoneID, uint8 skill, uint32 &npc_id,
 //we need this function to immediately determine, after we receive OP_Fishing, if we can even try to fish, otherwise we have to wait a while to get the failure
 bool Client::CanFish() {
 	//make sure we still have a fishing pole on:
-	const ItemInst* Pole = m_inv[SLOT_PRIMARY];
+	const ItemInst* Pole = m_inv[Legacy::SLOT_PRIMARY];
 	int32 bslot = m_inv.HasItemByUse(ItemTypeFishingBait, 1, invWhereWorn|invWherePersonal);
 	const ItemInst* Bait = nullptr;
-	if(bslot != SLOT_INVALID)
+	if(bslot != Legacy::SLOT_INVALID)
 		Bait = m_inv.GetItem(bslot);
 
 	if(!Pole || !Pole->IsType(ItemClassCommon) || Pole->GetItem()->ItemType != ItemTypeFishingPole) {
@@ -299,11 +299,11 @@ void Client::GoFish()
 	//make sure we still have a fishing pole on:
 	int32 bslot = m_inv.HasItemByUse(ItemTypeFishingBait, 1, invWhereWorn|invWherePersonal);
 	const ItemInst* Bait = nullptr;
-	if(bslot != SLOT_INVALID)
+	if(bslot != Legacy::SLOT_INVALID)
 		Bait = m_inv.GetItem(bslot);
 
 	//if the bait isnt equipped, need to add its skill bonus
-	if(bslot >= IDX_INV && Bait->GetItem()->SkillModType == SkillFishing) {
+	if(bslot >= Legacy::IDX_INV && Bait->GetItem()->SkillModType == SkillFishing) {
 		fishing_skill += Bait->GetItem()->SkillModValue;
 	}
 
@@ -360,12 +360,12 @@ void Client::GoFish()
 			else
 			{
 				PushItemOnCursor(*inst);
-				SendItemPacket(SLOT_CURSOR,inst,ItemPacketSummonItem);
+				SendItemPacket(Legacy::SLOT_CURSOR,inst,ItemPacketSummonItem);
 				if(RuleB(TaskSystem, EnableTaskSystem))
 					UpdateTasksForItem(ActivityFish, food_id);
 
 				safe_delete(inst);
-				inst = m_inv.GetItem(SLOT_CURSOR);
+				inst = m_inv.GetItem(Legacy::SLOT_CURSOR);
 			}
 		}
 
@@ -474,12 +474,12 @@ void Client::ForageItem(bool guarantee) {
 			}
 			else {
 				PushItemOnCursor(*inst);
-				SendItemPacket(SLOT_CURSOR, inst, ItemPacketSummonItem);
+				SendItemPacket(Legacy::SLOT_CURSOR, inst, ItemPacketSummonItem);
 				if(RuleB(TaskSystem, EnableTaskSystem))
 					UpdateTasksForItem(ActivityForage, foragedfood);
 
 				safe_delete(inst);
-				inst = m_inv.GetItem(SLOT_CURSOR);
+				inst = m_inv.GetItem(Legacy::SLOT_CURSOR);
 			}
 		}
 
diff --git a/zone/inventory.cpp b/zone/inventory.cpp
index 865eaa8..6c7464c 100644
--- a/zone/inventory.cpp
+++ b/zone/inventory.cpp
@@ -194,10 +194,10 @@ bool Client::CheckLoreConflict(const Item_Struct* item) {
 		return false;
 
 	if (item->LoreGroup == -1)	// Standard lore items; look everywhere except the shared bank, return the result
-		return (m_inv.HasItem(item->ID, 0, ~invWhereSharedBank) != SLOT_INVALID);
+		return (m_inv.HasItem(item->ID, 0, ~invWhereSharedBank) != Legacy::SLOT_INVALID);
 
 	//If the item has a lore group, we check for other items with the same group and return the result
-	return (m_inv.HasItemByLoreGroup(item->LoreGroup, ~invWhereSharedBank) != SLOT_INVALID);
+	return (m_inv.HasItemByLoreGroup(item->LoreGroup, ~invWhereSharedBank) != Legacy::SLOT_INVALID);
 }
 
 void Client::SummonItem(uint32 item_id, int16 charges, uint32 aug1, uint32 aug2, uint32 aug3, uint32 aug4, uint32 aug5, bool attuned, uint16 to_slot) {
@@ -290,12 +290,12 @@ void Client::SummonItem(uint32 item_id, int16 charges, uint32 aug1, uint32 aug2,
 					inst->SetInstNoDrop(true);
 				}
 			}
-			if (to_slot == SLOT_CURSOR)
+			if (to_slot == Legacy::SLOT_CURSOR)
 			{
 				//inst->SetCharges(
 				PushItemOnCursor(*inst);
 				// Send item packet to user
-				SendItemPacket(SLOT_CURSOR, inst, ItemPacketSummonItem);
+				SendItemPacket(Legacy::SLOT_CURSOR, inst, ItemPacketSummonItem);
 			}
 			else
 			{
@@ -344,7 +344,7 @@ void Client::DropItem(int16 slot_id)
 	}
 
 	// Save client inventory change to database
-	if(slot_id == SLOT_CURSOR) {
+	if(slot_id == Legacy::SLOT_CURSOR) {
 		std::list<ItemInst*>::const_iterator s=m_inv.cursor_begin(),e=m_inv.cursor_end();
 		database.SaveCursor(CharacterID(), s, e);
 	} else {
@@ -457,7 +457,7 @@ void Client::DeleteItemInInventory(int16 slot_id, int8 quantity, bool client_upd
 				ItemInst* bagitem = m_inv[slot_id]->GetItem(bag_idx);
 
 				if(bagitem) {
-					int16 bagslot_id = Inventory::CalcSlotId(slot_id, bag_idx);
+					int16 bagslot_id = Legacy::CalcSlotId(slot_id, bag_idx);
 
 					qsaudit->items[++parent_offset].char_slot	= bagslot_id;
 					qsaudit->items[parent_offset].item_id		= bagitem->GetID();
@@ -480,7 +480,7 @@ void Client::DeleteItemInInventory(int16 slot_id, int8 quantity, bool client_upd
 	bool isDeleted = m_inv.DeleteItem(slot_id, quantity);
 
 	const ItemInst* inst=nullptr;
-	if (slot_id==SLOT_CURSOR) {
+	if (slot_id==Legacy::SLOT_CURSOR) {
 		std::list<ItemInst*>::const_iterator s=m_inv.cursor_begin(),e=m_inv.cursor_end();
 		if(update_db)
 			database.SaveCursor(character_id, s, e);
@@ -532,7 +532,7 @@ bool Client::PushItemOnCursor(const ItemInst& inst, bool client_update)
 	m_inv.PushCursor(inst);
 
 	if (client_update) {
-		SendItemPacket(SLOT_CURSOR, &inst, ItemPacketSummonItem);
+		SendItemPacket(Legacy::SLOT_CURSOR, &inst, ItemPacketSummonItem);
 	}
 
 	std::list<ItemInst*>::const_iterator s=m_inv.cursor_begin(),e=m_inv.cursor_end();
@@ -542,7 +542,7 @@ bool Client::PushItemOnCursor(const ItemInst& inst, bool client_update)
 bool Client::PutItemInInventory(int16 slot_id, const ItemInst& inst, bool client_update)
 {
 	mlog(INVENTORY__SLOTS, "Putting item %s (%d) into slot %d", inst.GetItem()->Name, inst.GetItem()->ID, slot_id);
-	if (slot_id==SLOT_CURSOR)
+	if (slot_id==Legacy::SLOT_CURSOR)
 	{
 		return PushItemOnCursor(inst,client_update);
 	}
@@ -550,10 +550,10 @@ bool Client::PutItemInInventory(int16 slot_id, const ItemInst& inst, bool client
 		m_inv.PutItem(slot_id, inst);
 
 	if (client_update) {
-		SendItemPacket(slot_id, &inst, (slot_id==SLOT_CURSOR)?ItemPacketSummonItem:ItemPacketTrade);
+		SendItemPacket(slot_id, &inst, (slot_id==Legacy::SLOT_CURSOR)?ItemPacketSummonItem:ItemPacketTrade);
 	}
 
-	if (slot_id==SLOT_CURSOR) {
+	if (slot_id==Legacy::SLOT_CURSOR) {
 		std::list<ItemInst*>::const_iterator s=m_inv.cursor_begin(),e=m_inv.cursor_end();
 		return database.SaveCursor(this->CharacterID(), s, e);
 	} else
@@ -569,7 +569,7 @@ void Client::PutLootInInventory(int16 slot_id, const ItemInst &inst, ServerLootI
 
 	SendLootItemInPacket(&inst, slot_id);
 
-	if (slot_id==SLOT_CURSOR) {
+	if (slot_id==Legacy::SLOT_CURSOR) {
 		std::list<ItemInst*>::const_iterator s=m_inv.cursor_begin(),e=m_inv.cursor_end();
 		database.SaveCursor(this->CharacterID(), s, e);
 	} else
@@ -584,7 +584,7 @@ void Client::PutLootInInventory(int16 slot_id, const ItemInst &inst, ServerLootI
 			if(bag_item_data[i] == nullptr)
 				continue;
 			const ItemInst *bagitem = database.CreateItem(bag_item_data[i]->item_id, bag_item_data[i]->charges, bag_item_data[i]->aug1, bag_item_data[i]->aug2, bag_item_data[i]->aug3, bag_item_data[i]->aug4, bag_item_data[i]->aug5);
-			interior_slot = Inventory::CalcSlotId(slot_id, i);
+			interior_slot = Legacy::CalcSlotId(slot_id, i);
 			mlog(INVENTORY__SLOTS, "Putting bag loot item %s (%d) into slot %d (bag slot %d)", inst.GetItem()->Name, inst.GetItem()->ID, interior_slot, i);
 			PutLootInInventory(interior_slot, *bagitem);
 			safe_delete(bagitem);
@@ -613,7 +613,7 @@ bool Client::TryStacking(ItemInst* item, uint8 type, bool try_worn, bool try_cur
 	{
 		for (uint8 j = 0; j < 10; j++)
 		{
-			uint16 slotid = Inventory::CalcSlotId(i, j);
+			uint16 slotid = Legacy::CalcSlotId(i, j);
 			ItemInst* tmp_inst = m_inv.GetItem(slotid);
 
 			if(tmp_inst && tmp_inst->GetItem()->ID == item_id && tmp_inst->GetCharges() < tmp_inst->GetItem()->StackSize){
@@ -644,25 +644,25 @@ bool Client::AutoPutLootInInventory(ItemInst& inst, bool try_worn, bool try_curs
 
 			if (!m_inv[i])
 			{
-				if( i == SLOT_PRIMARY && inst.IsWeapon() ) // If item is primary slot weapon
+				if( i == Legacy::SLOT_PRIMARY && inst.IsWeapon() ) // If item is primary slot weapon
 				{
 					if( (inst.GetItem()->ItemType == ItemType2HSlash) || (inst.GetItem()->ItemType == ItemType2HBlunt) || (inst.GetItem()->ItemType == ItemType2HPiercing) ) // and uses 2hs \ 2hb \ 2hp
 					{
-						if( m_inv[SLOT_SECONDARY] ) // and if secondary slot is not empty
+						if( m_inv[Legacy::SLOT_SECONDARY] ) // and if secondary slot is not empty
 						{
 							continue; // Can't auto-equip
 						}
 					}
 				}
-				if( i== SLOT_SECONDARY && m_inv[SLOT_PRIMARY]) // check to see if primary slot is a two hander
+				if( i== Legacy::SLOT_SECONDARY && m_inv[Legacy::SLOT_PRIMARY]) // check to see if primary slot is a two hander
 				{
-					uint8 use = m_inv[SLOT_PRIMARY]->GetItem()->ItemType;
+					uint8 use = m_inv[Legacy::SLOT_PRIMARY]->GetItem()->ItemType;
 					if(use == ItemType2HSlash || use == ItemType2HBlunt || use == ItemType2HPiercing)
 						continue;
 				}
 				if
 				(
-					i == SLOT_SECONDARY &&
+					i == Legacy::SLOT_SECONDARY &&
 					inst.IsWeapon() &&
 					!CanThisClassDualWield()
 				)
@@ -697,7 +697,7 @@ bool Client::AutoPutLootInInventory(ItemInst& inst, bool try_worn, bool try_curs
 	// #3: put it in inventory
 	bool is_arrow = (inst.GetItem()->ItemType == ItemTypeArrow) ? true : false;
 	int16 slot_id = m_inv.FindFreeSlot(inst.IsType(ItemClassContainer), try_cursor, inst.GetItem()->Size, is_arrow);
-	if (slot_id != SLOT_INVALID)
+	if (slot_id != Legacy::SLOT_INVALID)
 	{
 		PutLootInInventory(slot_id, inst, bag_item_data);
 		return true;
@@ -725,7 +725,7 @@ void Client::MoveItemCharges(ItemInst &from, int16 to_slot, uint8 type)
 		tmp_inst->SetCharges(tmp_inst->GetCharges() + charges_to_move);
 		from.SetCharges(from.GetCharges() - charges_to_move);
 		SendLootItemInPacket(tmp_inst, to_slot);
-		if (to_slot==SLOT_CURSOR){
+		if (to_slot==Legacy::SLOT_CURSOR){
 			std::list<ItemInst*>::const_iterator s=m_inv.cursor_begin(),e=m_inv.cursor_end();
 			database.SaveCursor(this->CharacterID(), s, e);
 		} else
@@ -951,7 +951,7 @@ void Client::SendLootItemInPacket(const ItemInst* inst, int16 slot_id)
 
 bool Client::IsValidSlot(uint32 slot)
 {
-	if((slot == (uint32)SLOT_INVALID) ||	// Destroying/Dropping item
+	if((slot == (uint32)Legacy::SLOT_INVALID) ||	// Destroying/Dropping item
 		(slot >= 0 && slot <= 30) ||		// Worn inventory, normal inventory, and cursor
 		(slot >= 251 && slot <= 340) ||		// Normal inventory bags and cursor bag
 		(slot >= 400 && slot <= 404) ||		// Tribute
@@ -1014,12 +1014,12 @@ bool Client::SwapItem(MoveItem_Struct* move_in) {
 		return true;
 	}
 
-	if (move_in->to_slot == (uint32)SLOT_INVALID) {
-		if(move_in->from_slot == (uint32)SLOT_CURSOR) {
+	if (move_in->to_slot == (uint32)Legacy::SLOT_INVALID) {
+		if(move_in->from_slot == (uint32)Legacy::SLOT_CURSOR) {
 			mlog(INVENTORY__SLOTS, "Client destroyed item from cursor slot %d", move_in->from_slot);
 			if(RuleB(QueryServ, PlayerLogMoves)) { QSSwapItemAuditor(move_in); } // QS Audit
 
-			ItemInst *inst = m_inv.GetItem(SLOT_CURSOR);
+			ItemInst *inst = m_inv.GetItem(Legacy::SLOT_CURSOR);
 			if(inst) {
 				parse->EventItem(EVENT_DESTROY_ITEM, this, inst, nullptr, "", 0);
 			}
@@ -1034,9 +1034,9 @@ bool Client::SwapItem(MoveItem_Struct* move_in) {
 			return true; // Item deletetion
 		}
 	}
-	if(auto_attack && (move_in->from_slot == SLOT_PRIMARY || move_in->from_slot == SLOT_SECONDARY || move_in->from_slot == SLOT_RANGE))
+	if(auto_attack && (move_in->from_slot == Legacy::SLOT_PRIMARY || move_in->from_slot == Legacy::SLOT_SECONDARY || move_in->from_slot == Legacy::SLOT_RANGE))
 		SetAttackTimer();
-	else if(auto_attack && (move_in->to_slot == SLOT_PRIMARY || move_in->to_slot == SLOT_SECONDARY || move_in->to_slot == SLOT_RANGE))
+	else if(auto_attack && (move_in->to_slot == Legacy::SLOT_PRIMARY || move_in->to_slot == Legacy::SLOT_SECONDARY || move_in->to_slot == Legacy::SLOT_RANGE))
 		SetAttackTimer();
 	// Step 1: Variables
 	int16 src_slot_id = (int16)move_in->from_slot;
@@ -1127,8 +1127,8 @@ bool Client::SwapItem(MoveItem_Struct* move_in) {
 		if(src_slot_id >= 2500 && src_slot_id <= 2501 && src_inst->IsType(ItemClassContainer)){
 			for (uint8 idx=0; idx<10; idx++) {
 				const ItemInst* baginst = src_inst->GetItem(idx);
-				if(baginst && !database.VerifyInventory(account_id, Inventory::CalcSlotId(src_slot_id, idx), baginst)){
-					DeleteItemInInventory(Inventory::CalcSlotId(src_slot_id, idx),0,false);
+				if(baginst && !database.VerifyInventory(account_id, Legacy::CalcSlotId(src_slot_id, idx), baginst)){
+					DeleteItemInInventory(Legacy::CalcSlotId(src_slot_id, idx),0,false);
 				}
 			}
 		}
@@ -1142,8 +1142,8 @@ bool Client::SwapItem(MoveItem_Struct* move_in) {
 		if(dst_slot_id >= 2500 && dst_slot_id <= 2501 && dst_inst->IsType(ItemClassContainer)){
 			for (uint8 idx=0; idx<10; idx++) {
 				const ItemInst* baginst = dst_inst->GetItem(idx);
-				if(baginst && !database.VerifyInventory(account_id, Inventory::CalcSlotId(dst_slot_id, idx), baginst)){
-					DeleteItemInInventory(Inventory::CalcSlotId(dst_slot_id, idx),0,false);
+				if(baginst && !database.VerifyInventory(account_id, Legacy::CalcSlotId(dst_slot_id, idx), baginst)){
+					DeleteItemInInventory(Legacy::CalcSlotId(dst_slot_id, idx),0,false);
 				}
 			}
 		}
@@ -1165,7 +1165,7 @@ bool Client::SwapItem(MoveItem_Struct* move_in) {
 	if(m_tradeskill_object != nullptr) {
 		if (src_slot_id>=4000 && src_slot_id<=4009) {
 			// Picking up item from world container
-			ItemInst* inst = m_tradeskill_object->PopItem(Inventory::CalcBagIdx(src_slot_id));
+			ItemInst* inst = m_tradeskill_object->PopItem(Legacy::CalcBagIdx(src_slot_id));
 			if (inst) {
 				PutItemInInventory(dst_slot_id, *inst, false);
 				safe_delete(inst);
@@ -1177,7 +1177,7 @@ bool Client::SwapItem(MoveItem_Struct* move_in) {
 		}
 		else if (dst_slot_id>=4000 && dst_slot_id<=4009) {
 			// Putting item into world container, which may swap (or pile onto) with existing item
-			uint8 world_idx = Inventory::CalcBagIdx(dst_slot_id);
+			uint8 world_idx = Legacy::CalcBagIdx(dst_slot_id);
 			ItemInst* world_inst = m_tradeskill_object->PopItem(world_idx);
 
 			// Case 1: No item in container, unidirectional "Put"
@@ -1226,7 +1226,7 @@ bool Client::SwapItem(MoveItem_Struct* move_in) {
 			}
 
 			safe_delete(world_inst);
-			if (src_slot_id==SLOT_CURSOR) {
+			if (src_slot_id==Legacy::SLOT_CURSOR) {
 				std::list<ItemInst*>::const_iterator s=m_inv.cursor_begin(),e=m_inv.cursor_end();
 				database.SaveCursor(character_id, s, e);
 			} else
@@ -1240,14 +1240,14 @@ bool Client::SwapItem(MoveItem_Struct* move_in) {
 
 	// Step 4: Check for entity trade
 	if (dst_slot_id>=3000 && dst_slot_id<=3007) {
-		if (src_slot_id != SLOT_CURSOR) {
+		if (src_slot_id != Legacy::SLOT_CURSOR) {
 			Kick();
 			return false;
 		}
 		if (with) {
 			mlog(INVENTORY__SLOTS, "Trade item move from slot %d to slot %d (trade with %s)", src_slot_id, dst_slot_id, with->GetName());
 			// Fill Trade list with items from cursor
-			if (!m_inv[SLOT_CURSOR]) {
+			if (!m_inv[Legacy::SLOT_CURSOR]) {
 				Message(13, "Error: Cursor item not located on server!");
 				return false;
 			}
@@ -1263,7 +1263,7 @@ bool Client::SwapItem(MoveItem_Struct* move_in) {
 			if(RuleB(QueryServ, PlayerLogMoves)) { QSSwapItemAuditor(move_in); } // QS Audit
 
 			SummonItem(src_inst->GetID(), src_inst->GetCharges());
-			DeleteItemInInventory(SLOT_CURSOR);
+			DeleteItemInInventory(Legacy::SLOT_CURSOR);
 
 			return true;
 		}
@@ -1371,12 +1371,12 @@ bool Client::SwapItem(MoveItem_Struct* move_in) {
 	}
 
 	// Step 7: Save change to the database
-	if (src_slot_id==SLOT_CURSOR){
+	if (src_slot_id==Legacy::SLOT_CURSOR){
 		std::list<ItemInst*>::const_iterator s=m_inv.cursor_begin(),e=m_inv.cursor_end();
 		database.SaveCursor(character_id, s, e);
 	} else
 		database.SaveInventory(character_id, m_inv.GetItem(src_slot_id), src_slot_id);
-	if (dst_slot_id==SLOT_CURSOR) {
+	if (dst_slot_id==Legacy::SLOT_CURSOR) {
 		std::list<ItemInst*>::const_iterator s=m_inv.cursor_begin(),e=m_inv.cursor_end();
 		database.SaveCursor(character_id, s, e);
 	} else
@@ -1396,8 +1396,8 @@ void Client::SwapItemResync(MoveItem_Struct* move_slots) {
 	Message(15, "Inventory Desyncronization detected: Resending slot data...");
 
 	if((move_slots->from_slot >= 0 && move_slots->from_slot <= 340) || move_slots->from_slot == 9999) {
-		int16 resync_slot = (Inventory::CalcSlotId(move_slots->from_slot) == SLOT_INVALID) ? move_slots->from_slot : Inventory::CalcSlotId(move_slots->from_slot);
-		if(IsValidSlot(resync_slot) && resync_slot != SLOT_INVALID) {
+		int16 resync_slot = (Legacy::CalcSlotId(move_slots->from_slot) == Legacy::SLOT_INVALID) ? move_slots->from_slot : Legacy::CalcSlotId(move_slots->from_slot);
+		if(IsValidSlot(resync_slot) && resync_slot != Legacy::SLOT_INVALID) {
 			// This prevents the client from crashing when closing any 'phantom' bags -U
 			const Item_Struct* token_struct = database.GetItem(22292); // 'Copper Coin'
 			ItemInst* token_inst = database.CreateItem(token_struct, 1);
@@ -1420,8 +1420,8 @@ void Client::SwapItemResync(MoveItem_Struct* move_slots) {
 		else { Message(13, "Could not resyncronize source slot %i.", move_slots->from_slot); }
 	}
 	else {
-		int16 resync_slot = (Inventory::CalcSlotId(move_slots->from_slot) == SLOT_INVALID) ? move_slots->from_slot : Inventory::CalcSlotId(move_slots->from_slot);
-		if(IsValidSlot(resync_slot) && resync_slot != SLOT_INVALID) {
+		int16 resync_slot = (Legacy::CalcSlotId(move_slots->from_slot) == Legacy::SLOT_INVALID) ? move_slots->from_slot : Legacy::CalcSlotId(move_slots->from_slot);
+		if(IsValidSlot(resync_slot) && resync_slot != Legacy::SLOT_INVALID) {
 			if(m_inv[resync_slot]) {
 				const Item_Struct* token_struct = database.GetItem(22292); // 'Copper Coin'
 				ItemInst* token_inst = database.CreateItem(token_struct, 1);
@@ -1437,8 +1437,8 @@ void Client::SwapItemResync(MoveItem_Struct* move_slots) {
 	}
 
 	if((move_slots->to_slot >= 0 && move_slots->to_slot <= 340) || move_slots->to_slot == 9999) {
-		int16 resync_slot = (Inventory::CalcSlotId(move_slots->to_slot) == SLOT_INVALID) ? move_slots->to_slot : Inventory::CalcSlotId(move_slots->to_slot);
-		if(IsValidSlot(resync_slot) && resync_slot != SLOT_INVALID) {
+		int16 resync_slot = (Legacy::CalcSlotId(move_slots->to_slot) == Legacy::SLOT_INVALID) ? move_slots->to_slot : Legacy::CalcSlotId(move_slots->to_slot);
+		if(IsValidSlot(resync_slot) && resync_slot != Legacy::SLOT_INVALID) {
 			const Item_Struct* token_struct = database.GetItem(22292); // 'Copper Coin'
 			ItemInst* token_inst = database.CreateItem(token_struct, 1);
 
@@ -1460,8 +1460,8 @@ void Client::SwapItemResync(MoveItem_Struct* move_slots) {
 		else { Message(13, "Could not resyncronize destination slot %i.", move_slots->to_slot); }
 	}
 	else {
-		int16 resync_slot = (Inventory::CalcSlotId(move_slots->to_slot) == SLOT_INVALID) ? move_slots->to_slot : Inventory::CalcSlotId(move_slots->to_slot);
-		if(IsValidSlot(resync_slot) && resync_slot != SLOT_INVALID) {
+		int16 resync_slot = (Legacy::CalcSlotId(move_slots->to_slot) == Legacy::SLOT_INVALID) ? move_slots->to_slot : Legacy::CalcSlotId(move_slots->to_slot);
+		if(IsValidSlot(resync_slot) && resync_slot != Legacy::SLOT_INVALID) {
 			if(m_inv[resync_slot]) {
 				const Item_Struct* token_struct = database.GetItem(22292); // 'Copper Coin'
 				ItemInst* token_inst = database.CreateItem(token_struct, 1);
@@ -1519,8 +1519,8 @@ void Client::QSSwapItemAuditor(MoveItem_Struct* move_in, bool postaction_call) {
 				const ItemInst* from_baginst = from_inst->GetItem(bag_idx);
 
 				if(from_baginst) {
-					qsaudit->items[move_count].from_slot	= Inventory::CalcSlotId(from_slot_id, bag_idx);
-					qsaudit->items[move_count].to_slot		= Inventory::CalcSlotId(to_slot_id, bag_idx);
+					qsaudit->items[move_count].from_slot	= Legacy::CalcSlotId(from_slot_id, bag_idx);
+					qsaudit->items[move_count].to_slot		= Legacy::CalcSlotId(to_slot_id, bag_idx);
 					qsaudit->items[move_count].item_id		= from_baginst->GetID();
 					qsaudit->items[move_count].charges		= from_baginst->GetCharges();
 					qsaudit->items[move_count].aug_1		= from_baginst->GetAugmentItemID(1);
@@ -1552,8 +1552,8 @@ void Client::QSSwapItemAuditor(MoveItem_Struct* move_in, bool postaction_call) {
 					const ItemInst* to_baginst = to_inst->GetItem(bag_idx);
 
 					if(to_baginst) {
-						qsaudit->items[move_count].from_slot	= Inventory::CalcSlotId(to_slot_id, bag_idx);
-						qsaudit->items[move_count].to_slot		= Inventory::CalcSlotId(from_slot_id, bag_idx);
+						qsaudit->items[move_count].from_slot	= Legacy::CalcSlotId(to_slot_id, bag_idx);
+						qsaudit->items[move_count].to_slot		= Legacy::CalcSlotId(from_slot_id, bag_idx);
 						qsaudit->items[move_count].item_id		= to_baginst->GetID();
 						qsaudit->items[move_count].charges		= to_baginst->GetCharges();
 						qsaudit->items[move_count].aug_1		= to_baginst->GetAugmentItemID(1);
@@ -1582,7 +1582,7 @@ void Client::DyeArmor(DyeStruct* dye){
 			m_pp.item_tint[i].rgb.red!=dye->dye[i].rgb.red ||
 			m_pp.item_tint[i].rgb.green != dye->dye[i].rgb.green){
 			slot = m_inv.HasItem(32557, 1, invWherePersonal);
-			if(slot != SLOT_INVALID){
+			if(slot != Legacy::SLOT_INVALID){
 				DeleteItemInInventory(slot,1,true);
 				uint8 slot2=SlotConvert(i);
 				ItemInst* inst = this->m_inv.GetItem(slot2);
@@ -2008,13 +2008,13 @@ static int16 BandolierSlotToWeaponSlot(int BandolierSlot) {
 
 	switch(BandolierSlot) {
 		case bandolierMainHand:
-			return SLOT_PRIMARY;
+			return Legacy::SLOT_PRIMARY;
 		case bandolierOffHand:
-			return SLOT_SECONDARY;
+			return Legacy::SLOT_SECONDARY;
 		case bandolierRange:
-			return SLOT_RANGE;
+			return Legacy::SLOT_RANGE;
 		default:
-			return SLOT_AMMO;
+			return Legacy::SLOT_AMMO;
 	}
 }
 
@@ -2090,12 +2090,12 @@ void Client::SetBandolier(const EQApplicationPacket *app) {
 							invWhereWorn|invWherePersonal);
 
 			// removed 'invWhereCursor' argument from above and implemented slots 30, 331-340 checks here
-			if (slot == SLOT_INVALID) {
-				if (m_inv.GetItem(SLOT_CURSOR)) {
-					if (m_inv.GetItem(SLOT_CURSOR)->GetItem()->ID == m_pp.bandoliers[bss->number].items[BandolierSlot].item_id &&
-						m_inv.GetItem(SLOT_CURSOR)->GetCharges() >= 1) // '> 0' the same, but this matches Inventory::_HasItem conditional check
-							slot = SLOT_CURSOR;
-					else if (m_inv.GetItem(SLOT_CURSOR)->GetItem()->ItemClass == 1) {
+			if (slot == Legacy::SLOT_INVALID) {
+				if (m_inv.GetItem(Legacy::SLOT_CURSOR)) {
+					if (m_inv.GetItem(Legacy::SLOT_CURSOR)->GetItem()->ID == m_pp.bandoliers[bss->number].items[BandolierSlot].item_id &&
+						m_inv.GetItem(Legacy::SLOT_CURSOR)->GetCharges() >= 1) // '> 0' the same, but this matches Inventory::_HasItem conditional check
+							slot = Legacy::SLOT_CURSOR;
+					else if (m_inv.GetItem(Legacy::SLOT_CURSOR)->GetItem()->ItemClass == 1) {
 						for(int16 CursorBagSlot = 331; CursorBagSlot <= 340; CursorBagSlot++) {
 							if (m_inv.GetItem(CursorBagSlot)) {
 								if (m_inv.GetItem(CursorBagSlot)->GetItem()->ID == m_pp.bandoliers[bss->number].items[BandolierSlot].item_id &&
@@ -2110,7 +2110,7 @@ void Client::SetBandolier(const EQApplicationPacket *app) {
 			}
 
 			// if the player has this item in their inventory,
-			if(slot != SLOT_INVALID) {
+			if(slot != Legacy::SLOT_INVALID) {
 				// Pull the item out of the inventory
 				BandolierItems[BandolierSlot] = m_inv.PopItem(slot);
 				// If ammo with charges, only take one charge out to put in the range slot, that is what
@@ -2135,7 +2135,7 @@ void Client::SetBandolier(const EQApplicationPacket *app) {
 			}
 			else { // The player doesn't have the required weapon with them.
 				BandolierItems[BandolierSlot] = 0;
-				if(slot == SLOT_INVALID) {
+				if(slot == Legacy::SLOT_INVALID) {
 					_log(INVENTORY__BANDOLIER, "Character does not have required bandolier item for slot %i", WeaponSlot);
 					ItemInst *InvItem = m_inv.PopItem(WeaponSlot);
 					if(InvItem) {
@@ -2263,7 +2263,7 @@ bool Client::MoveItemToInventory(ItemInst *ItemToReturn, bool UpdateClient) {
 			//
 			if (InvItem && InvItem->IsType(ItemClassContainer)) {
 
-				int16 BaseSlotID = Inventory::CalcSlotId(i, 0);
+				int16 BaseSlotID = Legacy::CalcSlotId(i, 0);
 
 				uint8 BagSize=InvItem->GetItem()->BagSlots;
 
@@ -2318,7 +2318,7 @@ bool Client::MoveItemToInventory(ItemInst *ItemToReturn, bool UpdateClient) {
 		}
 		if(InvItem->IsType(ItemClassContainer) && Inventory::CanItemFitInContainer(ItemToReturn->GetItem(), InvItem->GetItem())) {
 
-			int16 BaseSlotID = Inventory::CalcSlotId(i, 0);
+			int16 BaseSlotID = Legacy::CalcSlotId(i, 0);
 
 			uint8 BagSize=InvItem->GetItem()->BagSlots;
 
diff --git a/zone/loottables.cpp b/zone/loottables.cpp
index e7adaff..0d999af 100644
--- a/zone/loottables.cpp
+++ b/zone/loottables.cpp
@@ -219,7 +219,7 @@ void NPC::AddLootDrop(const Item_Struct *item2, ItemList* itemlist, int16 charge
 		// it is an improvement.
 
 		if (!item2->NoPet) {
-			for (int i=0; !found && i<MAX_WORN_INVENTORY; i++) {
+			for (int i=0; !found && i<Legacy::MAX_WORN_INVENTORY; i++) {
 				uint32 slots = (1 << i);
 				if (item2->Slots & slots) {
 					if(equipment[i])
@@ -260,7 +260,7 @@ void NPC::AddLootDrop(const Item_Struct *item2, ItemList* itemlist, int16 charge
 		// @merth: IDFile size has been increased, this needs to change
 		uint16 emat;
 		if(item2->Material <= 0
-			|| item2->Slots & (1 << SLOT_PRIMARY | 1 << SLOT_SECONDARY)) {
+			|| item2->Slots & (1 << Legacy::SLOT_PRIMARY | 1 << Legacy::SLOT_SECONDARY)) {
 			memset(newid, 0, sizeof(newid));
 			for(int i=0;i<7;i++){
 				if (!isalpha(item2->IDFile[i])){
@@ -274,13 +274,13 @@ void NPC::AddLootDrop(const Item_Struct *item2, ItemList* itemlist, int16 charge
 			emat = item2->Material;
 		}
 
-		if (foundslot == SLOT_PRIMARY) {
+		if (foundslot == Legacy::SLOT_PRIMARY) {
 			if (item2->Proc.Effect != 0)
 				CastToMob()->AddProcToWeapon(item2->Proc.Effect, true);
 
 			eslot = MaterialPrimary;
 		}
-		else if (foundslot == SLOT_SECONDARY
+		else if (foundslot == Legacy::SLOT_SECONDARY
 			&& (GetOwner() != nullptr || (GetLevel() >= 13 && MakeRandomInt(0,99) < NPC_DW_CHANCE) || (item2->Damage==0)) &&
 			(item2->ItemType == ItemType1HSlash || item2->ItemType == ItemType1HBlunt || item2->ItemType == ItemTypeShield ||
 			item2->ItemType == ItemType1HPiercing))
@@ -290,25 +290,25 @@ void NPC::AddLootDrop(const Item_Struct *item2, ItemList* itemlist, int16 charge
 
 			eslot = MaterialSecondary;
 		}
-		else if (foundslot == SLOT_HEAD) {
+		else if (foundslot == Legacy::SLOT_HEAD) {
 			eslot = MaterialHead;
 		}
-		else if (foundslot == SLOT_CHEST) {
+		else if (foundslot == Legacy::SLOT_CHEST) {
 			eslot = MaterialChest;
 		}
-		else if (foundslot == SLOT_ARMS) {
+		else if (foundslot == Legacy::SLOT_ARMS) {
 			eslot = MaterialArms;
 		}
-		else if (foundslot == SLOT_BRACER01 || foundslot == SLOT_BRACER02) {
+		else if (foundslot == Legacy::SLOT_BRACER01 || foundslot == Legacy::SLOT_BRACER02) {
 			eslot = MaterialWrist;
 		}
-		else if (foundslot == SLOT_HANDS) {
+		else if (foundslot == Legacy::SLOT_HANDS) {
 			eslot = MaterialHands;
 		}
-		else if (foundslot == SLOT_LEGS) {
+		else if (foundslot == Legacy::SLOT_LEGS) {
 			eslot = MaterialLegs;
 		}
-		else if (foundslot == SLOT_FEET) {
+		else if (foundslot == Legacy::SLOT_FEET) {
 			eslot = MaterialFeet;
 		}
 
diff --git a/zone/lua_general.cpp b/zone/lua_general.cpp
index 5bddbd2..59264b5 100644
--- a/zone/lua_general.cpp
+++ b/zone/lua_general.cpp
@@ -1314,35 +1314,35 @@ luabind::scope lua_register_slot() {
 	return luabind::class_<Slots>("Slot")
 		.enum_("constants")
 		[
-			luabind::value("Charm", static_cast<int>(SLOT_CHARM)),
-			luabind::value("Ear1", static_cast<int>(SLOT_EAR01)),
-			luabind::value("Head", static_cast<int>(SLOT_HEAD)),
-			luabind::value("Face", static_cast<int>(SLOT_FACE)),
-			luabind::value("Ear2", static_cast<int>(SLOT_EAR02)),
-			luabind::value("Neck", static_cast<int>(SLOT_NECK)),
-			luabind::value("Shoulder", static_cast<int>(SLOT_SHOULDER)),
-			luabind::value("Arms", static_cast<int>(SLOT_ARMS)),
-			luabind::value("Back", static_cast<int>(SLOT_BACK)),
-			luabind::value("Bracer1", static_cast<int>(SLOT_BRACER01)),
-			luabind::value("Bracer2", static_cast<int>(SLOT_BRACER02)),
-			luabind::value("Range", static_cast<int>(SLOT_RANGE)),
-			luabind::value("Hands", static_cast<int>(SLOT_HANDS)),
-			luabind::value("Primary", static_cast<int>(SLOT_PRIMARY)),
-			luabind::value("Secondary", static_cast<int>(SLOT_SECONDARY)),
-			luabind::value("Ring1", static_cast<int>(SLOT_RING01)),
-			luabind::value("Ring2", static_cast<int>(SLOT_RING02)),
-			luabind::value("Chest", static_cast<int>(SLOT_CHEST)),
-			luabind::value("Legs", static_cast<int>(SLOT_LEGS)),
-			luabind::value("Feet", static_cast<int>(SLOT_FEET)),
-			luabind::value("Waist", static_cast<int>(SLOT_WAIST)),
-			luabind::value("Ammo", static_cast<int>(SLOT_AMMO)),
-			luabind::value("PersonalBegin", static_cast<int>(SLOT_PERSONAL_BEGIN)),
-			luabind::value("PersonalEnd", static_cast<int>(SLOT_PERSONAL_END)),
-			luabind::value("Cursor", static_cast<int>(SLOT_CURSOR)),
+			luabind::value("Charm", static_cast<int>(Legacy::SLOT_CHARM)),
+			luabind::value("Ear1", static_cast<int>(Legacy::SLOT_EAR01)),
+			luabind::value("Head", static_cast<int>(Legacy::SLOT_HEAD)),
+			luabind::value("Face", static_cast<int>(Legacy::SLOT_FACE)),
+			luabind::value("Ear2", static_cast<int>(Legacy::SLOT_EAR02)),
+			luabind::value("Neck", static_cast<int>(Legacy::SLOT_NECK)),
+			luabind::value("Shoulder", static_cast<int>(Legacy::SLOT_SHOULDER)),
+			luabind::value("Arms", static_cast<int>(Legacy::SLOT_ARMS)),
+			luabind::value("Back", static_cast<int>(Legacy::SLOT_BACK)),
+			luabind::value("Bracer1", static_cast<int>(Legacy::SLOT_BRACER01)),
+			luabind::value("Bracer2", static_cast<int>(Legacy::SLOT_BRACER02)),
+			luabind::value("Range", static_cast<int>(Legacy::SLOT_RANGE)),
+			luabind::value("Hands", static_cast<int>(Legacy::SLOT_HANDS)),
+			luabind::value("Primary", static_cast<int>(Legacy::SLOT_PRIMARY)),
+			luabind::value("Secondary", static_cast<int>(Legacy::SLOT_SECONDARY)),
+			luabind::value("Ring1", static_cast<int>(Legacy::SLOT_RING01)),
+			luabind::value("Ring2", static_cast<int>(Legacy::SLOT_RING02)),
+			luabind::value("Chest", static_cast<int>(Legacy::SLOT_CHEST)),
+			luabind::value("Legs", static_cast<int>(Legacy::SLOT_LEGS)),
+			luabind::value("Feet", static_cast<int>(Legacy::SLOT_FEET)),
+			luabind::value("Waist", static_cast<int>(Legacy::SLOT_WAIST)),
+			luabind::value("Ammo", static_cast<int>(Legacy::SLOT_AMMO)),
+			luabind::value("PersonalBegin", static_cast<int>(Legacy::SLOT_PERSONAL_BEGIN)),
+			luabind::value("PersonalEnd", static_cast<int>(Legacy::SLOT_PERSONAL_END)),
+			luabind::value("Cursor", static_cast<int>(Legacy::SLOT_CURSOR)),
 			luabind::value("CursorEnd", 0xFFFE),
-			luabind::value("Tradeskill", static_cast<int>(SLOT_TRADESKILL)),
-			luabind::value("Augment", static_cast<int>(SLOT_AUGMENT)),
-			luabind::value("PowerSource", static_cast<int>(SLOT_POWER_SOURCE)),
+			luabind::value("Tradeskill", static_cast<int>(Legacy::SLOT_TRADESKILL)),
+			luabind::value("Augment", static_cast<int>(Legacy::SLOT_AUGMENT)),
+			luabind::value("PowerSource", static_cast<int>(Legacy::SLOT_POWER_SOURCE)),
 			luabind::value("Invalid", 0xFFFF)
 		];
 }
diff --git a/zone/merc.cpp b/zone/merc.cpp
index 9d5fbe9..ed3c6cc 100644
--- a/zone/merc.cpp
+++ b/zone/merc.cpp
@@ -266,7 +266,7 @@ void Merc::CalcItemBonuses(StatBonuses* newbon) {
 
 	unsigned int i;
 	//should not include 21 (SLOT_AMMO)
-	for (i=0; i<SLOT_AMMO; i++) {
+	for (i=0; i<Legacy::SLOT_AMMO; i++) {
 		if(equipment[i] == 0)
 			continue;
 		const Item_Struct * itm = database.GetItem(equipment[i]);
@@ -1653,24 +1653,24 @@ void Merc::AI_Process() {
 
 				//try main hand first
 				if(attack_timer.Check()) {
-					Attack(GetTarget(), SLOT_PRIMARY);
+					Attack(GetTarget(), Legacy::SLOT_PRIMARY);
 
 					bool tripleSuccess = false;
 
 					if(GetOwner() && GetTarget() && CanThisClassDoubleAttack()) {
 
 						if(GetOwner()) {
-							Attack(GetTarget(), SLOT_PRIMARY, true);
+							Attack(GetTarget(), Legacy::SLOT_PRIMARY, true);
 						}
 
 						if(GetOwner() && GetTarget() && GetSpecialAbility(SPECATK_TRIPLE)) {
 							tripleSuccess = true;
-							Attack(GetTarget(), SLOT_PRIMARY, true);
+							Attack(GetTarget(), Legacy::SLOT_PRIMARY, true);
 						}
 
 						//quad attack, does this belong here??
 						if(GetOwner() && GetTarget() && GetSpecialAbility(SPECATK_QUAD)) {
-							Attack(GetTarget(), SLOT_PRIMARY, true);
+							Attack(GetTarget(), Legacy::SLOT_PRIMARY, true);
 						}
 					}
 
@@ -1682,8 +1682,8 @@ void Merc::AI_Process() {
 						if(MakeRandomInt(0, 100) < flurrychance)
 						{
 							Message_StringID(MT_NPCFlurry, 128);
-							Attack(GetTarget(), SLOT_PRIMARY, false);
-							Attack(GetTarget(), SLOT_PRIMARY, false);
+							Attack(GetTarget(), Legacy::SLOT_PRIMARY, false);
+							Attack(GetTarget(), Legacy::SLOT_PRIMARY, false);
 						}
 					}
 
@@ -1692,7 +1692,7 @@ void Merc::AI_Process() {
 					if (GetTarget() && ExtraAttackChanceBonus) {
 								if(MakeRandomInt(0, 100) < ExtraAttackChanceBonus)
 								{
-									Attack(GetTarget(), SLOT_PRIMARY, false);
+									Attack(GetTarget(), Legacy::SLOT_PRIMARY, false);
 								}
 							}
 				}
@@ -1727,11 +1727,11 @@ void Merc::AI_Process() {
 
 							if (random < DualWieldProbability){ // Max 78% of DW
 
-								Attack(GetTarget(), SLOT_SECONDARY);	// Single attack with offhand
+								Attack(GetTarget(), Legacy::SLOT_SECONDARY);	// Single attack with offhand
 
 								if( CanThisClassDoubleAttack()) {
 									if(GetTarget() && GetTarget()->GetHP() > -10)
-										Attack(GetTarget(), SLOT_SECONDARY);	// Single attack with offhand
+										Attack(GetTarget(), Legacy::SLOT_SECONDARY);	// Single attack with offhand
 								}
 							}
 						}
@@ -2640,7 +2640,7 @@ int16 Merc::GetFocusEffect(focusType type, uint16 spell_id) {
 		int16 focus_max_real = 0;
 
 		//item focus
-		for(int x =0; x < MAX_WORN_INVENTORY; ++x)
+		for(int x =0; x < Legacy::MAX_WORN_INVENTORY; ++x)
 		{
 			TempItem = nullptr;
 			if (equipment[x] == 0)
diff --git a/zone/merc.h b/zone/merc.h
index 192b565..26b2ddf 100644
--- a/zone/merc.h
+++ b/zone/merc.h
@@ -48,7 +48,7 @@ public:
 	//abstract virtual function implementations requird by base abstract class
 	virtual bool Death(Mob* killerMob, int32 damage, uint16 spell_id, SkillUseTypes attack_skill);
 	virtual void Damage(Mob* from, int32 damage, uint16 spell_id, SkillUseTypes attack_skill, bool avoidable = true, int8 buffslot = -1, bool iBuffTic = false);
-	virtual bool Attack(Mob* other, int Hand = SLOT_PRIMARY, bool FromRiposte = false, bool IsStrikethrough = false, 
+	virtual bool Attack(Mob* other, int Hand = Legacy::SLOT_PRIMARY, bool FromRiposte = false, bool IsStrikethrough = false, 
 		bool IsFromSpell = false, ExtraAttackOptions *opts = nullptr);
 	virtual bool HasRaid() { return false; }
 	virtual bool HasGroup() { return (GetGroup() ? true : false); }
@@ -275,7 +275,7 @@ protected:
 	std::map<uint32,MercTimer> timers;
 
 	uint16	skills[HIGHEST_SKILL+1];
-	uint32	equipment[MAX_WORN_INVENTORY];	//this is an array of item IDs
+	uint32	equipment[Legacy::MAX_WORN_INVENTORY];	//this is an array of item IDs
 	uint16	d_meele_texture1;			//this is an item Material value
 	uint16	d_meele_texture2;			//this is an item Material value (offhand)
 	uint8	prim_melee_type;			//Sets the Primary Weapon attack message and animation
diff --git a/zone/mob.cpp b/zone/mob.cpp
index bd06b27..3f963c2 100644
--- a/zone/mob.cpp
+++ b/zone/mob.cpp
@@ -1945,14 +1945,14 @@ void Mob::SetAttackTimer() {
 	Timer* TimerToUse = nullptr;
 	const Item_Struct* PrimaryWeapon = nullptr;
 
-	for (int i=SLOT_RANGE; i<=SLOT_SECONDARY; i++) {
+	for (int i=Legacy::SLOT_RANGE; i<=Legacy::SLOT_SECONDARY; i++) {
 
 		//pick a timer
-		if (i == SLOT_PRIMARY)
+		if (i == Legacy::SLOT_PRIMARY)
 			TimerToUse = &attack_timer;
-		else if (i == SLOT_RANGE)
+		else if (i == Legacy::SLOT_RANGE)
 			TimerToUse = &ranged_timer;
-		else if(i == SLOT_SECONDARY)
+		else if(i == Legacy::SLOT_SECONDARY)
 			TimerToUse = &attack_dw_timer;
 		else	//invalid slot (hands will always hit this)
 			continue;
@@ -1973,7 +1973,7 @@ void Mob::SetAttackTimer() {
 		}
 
 		//special offhand stuff
-		if(i == SLOT_SECONDARY) {
+		if(i == Legacy::SLOT_SECONDARY) {
 			//if we have a 2H weapon in our main hand, no dual
 			if(PrimaryWeapon != nullptr) {
 				if(	PrimaryWeapon->ItemClass == ItemClassCommon
@@ -2052,7 +2052,7 @@ void Mob::SetAttackTimer() {
 				if(IsClient())
 				{
 					float max_quiver = 0;
-					for(int r = SLOT_PERSONAL_BEGIN; r <= SLOT_PERSONAL_END; r++)
+					for(int r = Legacy::SLOT_PERSONAL_BEGIN; r <= Legacy::SLOT_PERSONAL_END; r++)
 					{
 						const ItemInst *pi = CastToClient()->GetInv().GetItem(r);
 						if(!pi)
@@ -2076,7 +2076,7 @@ void Mob::SetAttackTimer() {
 			TimerToUse->SetAtTrigger(speed, true);
 		}
 
-		if(i == SLOT_PRIMARY)
+		if(i == Legacy::SLOT_PRIMARY)
 			PrimaryWeapon = ItemToUse;
 	}
 
@@ -2087,7 +2087,7 @@ bool Mob::CanThisClassDualWield(void) const
 	if (!IsClient()) {
 		return(GetSkill(SkillDualWield) > 0);
 	} else {
-		const ItemInst* inst = CastToClient()->GetInv().GetItem(SLOT_PRIMARY);
+		const ItemInst* inst = CastToClient()->GetInv().GetItem(Legacy::SLOT_PRIMARY);
 		// 2HS, 2HB, or 2HP
 		if (inst && inst->IsType(ItemClassCommon)) {
 			const Item_Struct* item = inst->GetItem();
diff --git a/zone/npc.cpp b/zone/npc.cpp
index ccff8a7..16f776b 100644
--- a/zone/npc.cpp
+++ b/zone/npc.cpp
@@ -1291,7 +1291,7 @@ void NPC::PickPocket(Client* thief) {
 				bool is_arrow = (item->ItemType == ItemTypeArrow) ? true : false;
 				int slot_id = thief->GetInv().FindFreeSlot(false, true, inst->GetItem()->Size, is_arrow);
 				if (/*!Equipped(item->ID) &&*/
-					!item->Magic && item->NoDrop != 0 && !inst->IsType(ItemClassContainer) && slot_id != SLOT_INVALID
+					!item->Magic && item->NoDrop != 0 && !inst->IsType(ItemClassContainer) && slot_id != Legacy::SLOT_INVALID
 					/*&& steal_skill > item->StealSkill*/ )
 				{
 					slot[x] = slot_id;
diff --git a/zone/npc.h b/zone/npc.h
index 5e568d5..3717367 100644
--- a/zone/npc.h
+++ b/zone/npc.h
@@ -432,7 +432,7 @@ protected:
 	uint32 roambox_delay;
 
 	uint16	skills[HIGHEST_SKILL+1];
-	uint32	equipment[MAX_WORN_INVENTORY];	//this is an array of item IDs
+	uint32	equipment[Legacy::MAX_WORN_INVENTORY];	//this is an array of item IDs
 	uint16	d_meele_texture1;			//this is an item Material value
 	uint16	d_meele_texture2;			//this is an item Material value (offhand)
 	uint8	prim_melee_type;			//Sets the Primary Weapon attack message and animation
diff --git a/zone/pets.cpp b/zone/pets.cpp
index 7254f26..814be8d 100644
--- a/zone/pets.cpp
+++ b/zone/pets.cpp
@@ -411,12 +411,12 @@ void Mob::MakePoweredPet(uint16 spell_id, const char* pettype, int16 petpower,
 	// the base items for the pet. These are always loaded
 	// so that a rank 1 suspend minion does not kill things
 	// like the special back items some focused pets may receive.
-	uint32 petinv[MAX_WORN_INVENTORY];
+	uint32 petinv[Legacy::MAX_WORN_INVENTORY];
 	memset(petinv, 0, sizeof(petinv));
 	const Item_Struct *item = 0;
 
 	if (database.GetBasePetItems(record.equipmentset, petinv)) {
-		for (int i=0; i<MAX_WORN_INVENTORY; i++)
+		for (int i=0; i<Legacy::MAX_WORN_INVENTORY; i++)
 			if (petinv[i]) {
 				item = database.GetItem(petinv[i]);
 				npc->AddLootDrop(item, &npc->itemlist, 0, 1, 127, true, true);
@@ -543,7 +543,7 @@ void NPC::GetPetState(SpellBuff_Struct *pet_buffs, uint32 *items, char *name) {
 	strn0cpy(name, GetName(), 64);
 
 	//save their items, we only care about what they are actually wearing
-	memcpy(items, equipment, sizeof(uint32)*MAX_WORN_INVENTORY);
+	memcpy(items, equipment, sizeof(uint32)*Legacy::MAX_WORN_INVENTORY);
 
 	//save their buffs.
 	for (int i=0; i < GetPetMaxTotalSlots(); i++) {
@@ -630,7 +630,7 @@ void NPC::SetPetState(SpellBuff_Struct *pet_buffs, uint32 *items) {
 	UpdateRuneFlags();
 
 	//restore their equipment...
-	for(i = 0; i < MAX_WORN_INVENTORY; i++) {
+	for(i = 0; i < Legacy::MAX_WORN_INVENTORY; i++) {
 		if(items[i] == 0)
 			continue;
 
@@ -694,7 +694,7 @@ bool ZoneDatabase::GetBasePetItems(int32 equipmentset, uint32 *items) {
 					while ((row = mysql_fetch_row(result)))
 					{
 						slot = atoi(row[0]);
-						if (slot >= MAX_WORN_INVENTORY)
+						if (slot >= Legacy::MAX_WORN_INVENTORY)
 							continue;
 						if (items[slot] == 0)
 							items[slot] = atoi(row[1]);
diff --git a/zone/special_attacks.cpp b/zone/special_attacks.cpp
index 226f61c..b72acf8 100644
--- a/zone/special_attacks.cpp
+++ b/zone/special_attacks.cpp
@@ -74,17 +74,17 @@ void Mob::ApplySpecialAttackMod(SkillUseTypes skill, int32 &dmg, int32 &mindmg)
 			case SkillFlyingKick:
 			case SkillRoundKick:
 			case SkillKick:
-				item_slot = SLOT_FEET;
+				item_slot = Legacy::SLOT_FEET;
 				break;
 
 			case SkillBash:
-				item_slot = SLOT_SECONDARY;
+				item_slot = Legacy::SLOT_SECONDARY;
 				break;
 
 			case SkillDragonPunch:
 			case SkillEagleStrike:
 			case SkillTigerClaw:
-				item_slot = SLOT_HANDS;
+				item_slot = Legacy::SLOT_HANDS;
 				break;
 
 			default:
@@ -112,7 +112,7 @@ void Mob::DoSpecialAttackDamage(Mob *who, SkillUseTypes skill, int32 max_damage,
 	{
 		if(IsClient())
 		{
-			ItemInst *item = CastToClient()->GetInv().GetItem(SLOT_SECONDARY);
+			ItemInst *item = CastToClient()->GetInv().GetItem(Legacy::SLOT_SECONDARY);
 			if(item)
 			{
 				if(item->GetItem()->ItemType == ItemTypeShield)
@@ -242,8 +242,8 @@ void Client::OPCombatAbility(const EQApplicationPacket *app) {
 			DoAnim(animTailRake);
 
 			int32 ht = 0;
-			if(GetWeaponDamage(GetTarget(), GetInv().GetItem(SLOT_SECONDARY)) <= 0 &&
-				GetWeaponDamage(GetTarget(), GetInv().GetItem(SLOT_SHOULDER)) <= 0){
+			if(GetWeaponDamage(GetTarget(), GetInv().GetItem(Legacy::SLOT_SECONDARY)) <= 0 &&
+				GetWeaponDamage(GetTarget(), GetInv().GetItem(Legacy::SLOT_SHOULDER)) <= 0){
 				dmg = -5;
 			}
 			else{
@@ -322,7 +322,7 @@ void Client::OPCombatAbility(const EQApplicationPacket *app) {
 				DoAnim(animKick);
 
 				int32 ht = 0;
-				if(GetWeaponDamage(GetTarget(), GetInv().GetItem(SLOT_FEET)) <= 0){
+				if(GetWeaponDamage(GetTarget(), GetInv().GetItem(Legacy::SLOT_FEET)) <= 0){
 					dmg = -5;
 				}
 				else{
@@ -403,7 +403,7 @@ int Mob::MonkSpecialAttack(Mob* other, uint8 unchecked_type)
 	int32 min_dmg = 1;
 	int reuse = 0;
 	SkillUseTypes skill_type;	//to avoid casting... even though it "would work"
-	uint8 itemslot = SLOT_FEET;
+	uint8 itemslot = Legacy::SLOT_FEET;
 
 	switch(unchecked_type)
 	{
@@ -419,7 +419,7 @@ int Mob::MonkSpecialAttack(Mob* other, uint8 unchecked_type)
 		case SkillDragonPunch:{
 			skill_type = SkillDragonPunch;
 			max_dmg = ((GetSTR()+GetSkill(skill_type)) * RuleI(Combat, DragonPunchBonus) / 100) + 26;
-			itemslot = SLOT_HANDS;
+			itemslot = Legacy::SLOT_HANDS;
 			ApplySpecialAttackMod(skill_type, max_dmg, min_dmg);
 			DoAnim(animTailRake);
 			reuse = TailRakeReuseTime;
@@ -429,7 +429,7 @@ int Mob::MonkSpecialAttack(Mob* other, uint8 unchecked_type)
 		case SkillEagleStrike:{
 			skill_type = SkillEagleStrike;
 			max_dmg = ((GetSTR()+GetSkill(skill_type)) * RuleI(Combat, EagleStrikeBonus) / 100) + 19;
-			itemslot = SLOT_HANDS;
+			itemslot = Legacy::SLOT_HANDS;
 			ApplySpecialAttackMod(skill_type, max_dmg, min_dmg);
 			DoAnim(animEagleStrike);
 			reuse = EagleStrikeReuseTime;
@@ -439,7 +439,7 @@ int Mob::MonkSpecialAttack(Mob* other, uint8 unchecked_type)
 		case SkillTigerClaw:{
 			skill_type = SkillTigerClaw;
 			max_dmg = ((GetSTR()+GetSkill(skill_type)) * RuleI(Combat, TigerClawBonus) / 100) + 12;
-			itemslot = SLOT_HANDS;
+			itemslot = Legacy::SLOT_HANDS;
 			ApplySpecialAttackMod(skill_type, max_dmg, min_dmg);
 			DoAnim(animTigerClaw);
 			reuse = TigerClawReuseTime;
@@ -509,7 +509,7 @@ void Mob::TryBackstab(Mob *other, int ReuseTime) {
 
 	//make sure we have a proper weapon if we are a client.
 	if(IsClient()) {
-		const ItemInst *wpn = CastToClient()->GetInv().GetItem(SLOT_PRIMARY);
+		const ItemInst *wpn = CastToClient()->GetInv().GetItem(Legacy::SLOT_PRIMARY);
 		if(!wpn || (wpn->GetItem()->ItemType != ItemType1HPiercing)){
 			Message_StringID(13, BACKSTAB_WEAPON);
 			return;
@@ -605,7 +605,7 @@ void Mob::RogueBackstab(Mob* other, bool min_damage, int ReuseTime)
 
 	if(IsClient()){
 		const ItemInst *wpn = nullptr;
-		wpn = CastToClient()->GetInv().GetItem(SLOT_PRIMARY);
+		wpn = CastToClient()->GetInv().GetItem(Legacy::SLOT_PRIMARY);
 		primaryweapondamage = GetWeaponDamage(other, wpn);
 		backstab_dmg = wpn->GetItem()->BackstabDmg;
 		for(int i = 0; i < MAX_AUGMENT_SLOTS; ++i)
@@ -678,7 +678,7 @@ void Mob::RogueAssassinate(Mob* other)
 {
 	//can you dodge, parry, etc.. an assassinate??
 	//if so, use DoSpecialAttackDamage(other, BACKSTAB, 32000); instead
-	if(GetWeaponDamage(other, IsClient()?CastToClient()->GetInv().GetItem(SLOT_PRIMARY):(const ItemInst*)nullptr) > 0){
+	if(GetWeaponDamage(other, IsClient()?CastToClient()->GetInv().GetItem(Legacy::SLOT_PRIMARY):(const ItemInst*)nullptr) > 0){
 		other->Damage(this, 32000, SPELL_UNKNOWN, SkillBackstab);
 	}else{
 		other->Damage(this, -5, SPELL_UNKNOWN, SkillBackstab);
@@ -697,20 +697,20 @@ void Client::RangedAttack(Mob* other, bool CanDoubleAttack) {
 		//Message(0, "Error: Timer not up. Attack %d, ranged %d", attack_timer.GetRemainingTime(), ranged_timer.GetRemainingTime());
 		return;
 	}
-	const ItemInst* RangeWeapon = m_inv[SLOT_RANGE];
+	const ItemInst* RangeWeapon = m_inv[Legacy::SLOT_RANGE];
 
 	//locate ammo
-	int ammo_slot = SLOT_AMMO;
-	const ItemInst* Ammo = m_inv[SLOT_AMMO];
+	int ammo_slot = Legacy::SLOT_AMMO;
+	const ItemInst* Ammo = m_inv[Legacy::SLOT_AMMO];
 
 	if (!RangeWeapon || !RangeWeapon->IsType(ItemClassCommon)) {
-		mlog(COMBAT__RANGED, "Ranged attack canceled. Missing or invalid ranged weapon (%d) in slot %d", GetItemIDAt(SLOT_RANGE), SLOT_RANGE);
-		Message(0, "Error: Rangeweapon: GetItem(%i)==0, you have no bow!", GetItemIDAt(SLOT_RANGE));
+		mlog(COMBAT__RANGED, "Ranged attack canceled. Missing or invalid ranged weapon (%d) in slot %d", GetItemIDAt(Legacy::SLOT_RANGE), Legacy::SLOT_RANGE);
+		Message(0, "Error: Rangeweapon: GetItem(%i)==0, you have no bow!", GetItemIDAt(Legacy::SLOT_RANGE));
 		return;
 	}
 	if (!Ammo || !Ammo->IsType(ItemClassCommon)) {
-		mlog(COMBAT__RANGED, "Ranged attack canceled. Missing or invalid ammo item (%d) in slot %d", GetItemIDAt(SLOT_AMMO), SLOT_AMMO);
-		Message(0, "Error: Ammo: GetItem(%i)==0, you have no ammo!", GetItemIDAt(SLOT_AMMO));
+		mlog(COMBAT__RANGED, "Ranged attack canceled. Missing or invalid ammo item (%d) in slot %d", GetItemIDAt(Legacy::SLOT_AMMO), Legacy::SLOT_AMMO);
+		Message(0, "Error: Ammo: GetItem(%i)==0, you have no ammo!", GetItemIDAt(Legacy::SLOT_AMMO));
 		return;
 	}
 
@@ -735,7 +735,7 @@ void Client::RangedAttack(Mob* other, bool CanDoubleAttack) {
 		//first look for quivers
 		int r;
 		bool found = false;
-		for(r = SLOT_PERSONAL_BEGIN; r <= SLOT_PERSONAL_END; r++) {
+		for(r = Legacy::SLOT_PERSONAL_BEGIN; r <= Legacy::SLOT_PERSONAL_END; r++) {
 			const ItemInst *pi = m_inv[r];
 			if(pi == nullptr || !pi->IsType(ItemClassContainer))
 				continue;
@@ -753,7 +753,7 @@ void Client::RangedAttack(Mob* other, bool CanDoubleAttack) {
 					//we found it... use this stack
 					//the item wont change, but the instance does
 					Ammo = baginst;
-					ammo_slot = m_inv.CalcSlotId(r, i);
+					ammo_slot = Legacy::CalcSlotId(r, i);
 					found = true;
 					mlog(COMBAT__RANGED, "Using ammo from quiver stack at slot %d. %d in stack.", ammo_slot, Ammo->GetCharges());
 					break;
@@ -767,7 +767,7 @@ void Client::RangedAttack(Mob* other, bool CanDoubleAttack) {
 			//if we dont find a quiver, look through our inventory again
 			//not caring if the thing is a quiver.
 			int32 aslot = m_inv.HasItem(AmmoItem->ID, 1, invWherePersonal);
-			if(aslot != SLOT_INVALID) {
+			if(aslot != Legacy::SLOT_INVALID) {
 				ammo_slot = aslot;
 				Ammo = m_inv[aslot];
 				mlog(COMBAT__RANGED, "Using ammo from inventory stack at slot %d. %d in stack.", ammo_slot, Ammo->GetCharges());
@@ -1132,19 +1132,19 @@ void Client::ThrowingAttack(Mob* other, bool CanDoubleAttack) { //old was 51
 		return;
 	}
 
-	int ammo_slot = SLOT_RANGE;
-	const ItemInst* RangeWeapon = m_inv[SLOT_RANGE];
+	int ammo_slot = Legacy::SLOT_RANGE;
+	const ItemInst* RangeWeapon = m_inv[Legacy::SLOT_RANGE];
 
 	if (!RangeWeapon || !RangeWeapon->IsType(ItemClassCommon)) {
-		mlog(COMBAT__RANGED, "Ranged attack canceled. Missing or invalid ranged weapon (%d) in slot %d", GetItemIDAt(SLOT_RANGE), SLOT_RANGE);
-		Message(0, "Error: Rangeweapon: GetItem(%i)==0, you have nothing to throw!", GetItemIDAt(SLOT_RANGE));
+		mlog(COMBAT__RANGED, "Ranged attack canceled. Missing or invalid ranged weapon (%d) in slot %d", GetItemIDAt(Legacy::SLOT_RANGE), Legacy::SLOT_RANGE);
+		Message(0, "Error: Rangeweapon: GetItem(%i)==0, you have nothing to throw!", GetItemIDAt(Legacy::SLOT_RANGE));
 		return;
 	}
 
 	const Item_Struct* item = RangeWeapon->GetItem();
 	if(item->ItemType != ItemTypeLargeThrowing && item->ItemType != ItemTypeSmallThrowing) {
 		mlog(COMBAT__RANGED, "Ranged attack canceled. Ranged item %d is not a throwing weapon. type %d.", item->ItemType);
-		Message(0, "Error: Rangeweapon: GetItem(%i)==0, you have nothing useful to throw!", GetItemIDAt(SLOT_RANGE));
+		Message(0, "Error: Rangeweapon: GetItem(%i)==0, you have nothing useful to throw!", GetItemIDAt(Legacy::SLOT_RANGE));
 		return;
 	}
 
@@ -1152,16 +1152,16 @@ void Client::ThrowingAttack(Mob* other, bool CanDoubleAttack) { //old was 51
 
 	if(RangeWeapon->GetCharges() == 1) {
 		//first check ammo
-		const ItemInst* AmmoItem = m_inv[SLOT_AMMO];
+		const ItemInst* AmmoItem = m_inv[Legacy::SLOT_AMMO];
 		if(AmmoItem != nullptr && AmmoItem->GetID() == RangeWeapon->GetID()) {
 			//more in the ammo slot, use it
 			RangeWeapon = AmmoItem;
-			ammo_slot = SLOT_AMMO;
+			ammo_slot = Legacy::SLOT_AMMO;
 			mlog(COMBAT__RANGED, "Using ammo from ammo slot, stack at slot %d. %d in stack.", ammo_slot, RangeWeapon->GetCharges());
 		} else {
 			//look through our inventory for more
 			int32 aslot = m_inv.HasItem(item->ID, 1, invWherePersonal);
-			if(aslot != SLOT_INVALID) {
+			if(aslot != Legacy::SLOT_INVALID) {
 				//the item wont change, but the instance does, not that it matters
 				ammo_slot = aslot;
 				RangeWeapon = m_inv[aslot];
@@ -1700,8 +1700,8 @@ void Client::DoClassAttacks(Mob *ca_target, uint16 skill, bool IsRiposte)
 		{
 			DoAnim(animTailRake);
 
-			if(GetWeaponDamage(ca_target, GetInv().GetItem(SLOT_SECONDARY)) <= 0 &&
-				GetWeaponDamage(ca_target, GetInv().GetItem(SLOT_SHOULDER)) <= 0){
+			if(GetWeaponDamage(ca_target, GetInv().GetItem(Legacy::SLOT_SECONDARY)) <= 0 &&
+				GetWeaponDamage(ca_target, GetInv().GetItem(Legacy::SLOT_SHOULDER)) <= 0){
 				dmg = -5;
 			}
 			else{
@@ -1771,7 +1771,7 @@ void Client::DoClassAttacks(Mob *ca_target, uint16 skill, bool IsRiposte)
 		{
 			DoAnim(animKick);
 
-			if(GetWeaponDamage(ca_target, GetInv().GetItem(SLOT_FEET)) <= 0){
+			if(GetWeaponDamage(ca_target, GetInv().GetItem(Legacy::SLOT_FEET)) <= 0){
 				dmg = -5;
 			}
 			else{
@@ -2157,7 +2157,7 @@ void Mob::DoMeleeSkillAttackDmg(Mob* other, uint16 weapon_damage, SkillUseTypes
 
 	if(skillinuse == SkillBash){
 		if(IsClient()){
-			ItemInst *item = CastToClient()->GetInv().GetItem(SLOT_SECONDARY);
+			ItemInst *item = CastToClient()->GetInv().GetItem(Legacy::SLOT_SECONDARY);
 			if(item){
 				if(item->GetItem()->ItemType == ItemTypeShield)	{
 					hate += item->GetItem()->AC;
diff --git a/zone/spell_effects.cpp b/zone/spell_effects.cpp
index 841abca..fb3ce90 100644
--- a/zone/spell_effects.cpp
+++ b/zone/spell_effects.cpp
@@ -699,7 +699,7 @@ bool Mob::SpellEffect(Mob* caster, uint16 spell_id, float partial)
 				snprintf(effect_desc, _EDLEN, "Flesh To Bone");
 #endif
 				if(IsClient()){
-					ItemInst* transI = CastToClient()->GetInv().GetItem(SLOT_CURSOR);
+					ItemInst* transI = CastToClient()->GetInv().GetItem(Legacy::SLOT_CURSOR);
 					if(transI && transI->IsType(ItemClassCommon) && transI->IsStackable()){
 						uint32 fcharges = transI->GetCharges();
 							//Does it sound like meat... maybe should check if it looks like meat too...
@@ -709,7 +709,7 @@ bool Mob::SpellEffect(Mob* caster, uint16 spell_id, float partial)
 								strstr(transI->GetItem()->Name, "Flesh") ||
 								strstr(transI->GetItem()->Name, "parts") ||
 								strstr(transI->GetItem()->Name, "Parts")){
-								CastToClient()->DeleteItemInInventory(SLOT_CURSOR, fcharges, true);
+								CastToClient()->DeleteItemInInventory(Legacy::SLOT_CURSOR, fcharges, true);
 								CastToClient()->SummonItem(13073, fcharges);
 							}
 							else{
@@ -1233,7 +1233,7 @@ bool Mob::SpellEffect(Mob* caster, uint16 spell_id, float partial)
 
 						if (SummonedItem) {
 							c->PushItemOnCursor(*SummonedItem);
-							c->SendItemPacket(SLOT_CURSOR, SummonedItem, ItemPacketSummonItem);
+							c->SendItemPacket(Legacy::SLOT_CURSOR, SummonedItem, ItemPacketSummonItem);
 							safe_delete(SummonedItem);
 						}
 						SummonedItem = database.CreateItem(spell.base[i], charges);
@@ -2954,7 +2954,7 @@ bool Mob::SpellEffect(Mob* caster, uint16 spell_id, float partial)
 	if (SummonedItem) {
 		Client *c=CastToClient();
 		c->PushItemOnCursor(*SummonedItem);
-		c->SendItemPacket(SLOT_CURSOR, SummonedItem, ItemPacketSummonItem);
+		c->SendItemPacket(Legacy::SLOT_CURSOR, SummonedItem, ItemPacketSummonItem);
 		safe_delete(SummonedItem);
 	}
 
diff --git a/zone/titles.cpp b/zone/titles.cpp
index de79fa8..179b0ca 100644
--- a/zone/titles.cpp
+++ b/zone/titles.cpp
@@ -201,7 +201,7 @@ bool TitleManager::IsClientEligibleForTitle(Client *c, std::vector<TitleEntry>::
 
 		}
 
-		if((Title->ItemID >= 1) && (c->GetInv().HasItem(Title->ItemID, 0, 0xFF) == SLOT_INVALID))
+		if((Title->ItemID >= 1) && (c->GetInv().HasItem(Title->ItemID, 0, 0xFF) == Legacy::SLOT_INVALID))
 			return false;
 
 		if((Title->TitleSet > 0) && (!c->CheckTitle(Title->TitleSet)))
diff --git a/zone/tradeskills.cpp b/zone/tradeskills.cpp
index 5df392f..e5c6a19 100644
--- a/zone/tradeskills.cpp
+++ b/zone/tradeskills.cpp
@@ -217,7 +217,7 @@ void Object::HandleAugmentation(Client* user, const AugmentItem_Struct* in_augme
 				const ItemInst* inst = container->GetItem(i);
 				if (inst)
 				{
-					user->DeleteItemInInventory(Inventory::CalcSlotId(in_augment->container_slot,i),0,true);
+					user->DeleteItemInInventory(Legacy::CalcSlotId(in_augment->container_slot,i),0,true);
 				}
 			}
 			// Explicitly mark container as cleared.
@@ -254,7 +254,7 @@ void Object::HandleCombine(Client* user, const NewCombine_Struct* in_combine, Ob
 	uint32 some_id = 0;
 	bool worldcontainer=false;
 
-	if (in_combine->container_slot == SLOT_TRADESKILL) {
+	if (in_combine->container_slot == Legacy::SLOT_TRADESKILL) {
 		if(!worldo) {
 			user->Message(13, "Error: Server is not aware of the tradeskill container you are attempting to use");
 			return;
@@ -356,7 +356,7 @@ void Object::HandleCombine(Client* user, const NewCombine_Struct* in_combine, Ob
 		for (uint8 i=0; i<10; i++){
 			const ItemInst* inst = container->GetItem(i);
 			if (inst) {
-				user->DeleteItemInInventory(Inventory::CalcSlotId(in_combine->container_slot,i),0,true);
+				user->DeleteItemInInventory(Legacy::CalcSlotId(in_combine->container_slot,i),0,true);
 			}
 		}
 		container->Clear();
@@ -482,7 +482,7 @@ void Object::HandleAutoCombine(Client* user, const RecipeAutoCombine_Struct* rac
 		//because a HasItem on items with num > 1 only returns the
 		//last-most slot... the results of this are useless to us
 		//when we go to delete them because we cannot assume it is in a single stack.
-		if(user_inv.HasItem(item, num, invWherePersonal) != SLOT_INVALID)
+		if(user_inv.HasItem(item, num, invWherePersonal) != Legacy::SLOT_INVALID)
 			count += num;
 		else
 			MissingItems.push_back(item);
@@ -524,7 +524,7 @@ void Object::HandleAutoCombine(Client* user, const RecipeAutoCombine_Struct* rac
 		//we have to loop here to delete 1 at a time in case its in multiple stacks.
 		for(k = 0; k < counts[r]; k++) {
 			slot = user_inv.HasItem(items[r], 1, invWherePersonal);
-			if(slot == SLOT_INVALID) {
+			if(slot == Legacy::SLOT_INVALID) {
 				//WTF... I just checked this above, but just to be sure...
 				//we cant undo the previous deletes without a lot of work.
 				//so just call it quits, this shouldent ever happen anyways.
diff --git a/zone/trading.cpp b/zone/trading.cpp
index bc1a248..f713e29 100644
--- a/zone/trading.cpp
+++ b/zone/trading.cpp
@@ -87,7 +87,7 @@ void Trade::AddEntity(uint16 from_slot_id, uint16 trade_slot_id)
 
 	// Item always goes into trade bucket from cursor
 	Client* client = owner->CastToClient();
-	const ItemInst* inst = client->GetInv().GetItem(SLOT_CURSOR);
+	const ItemInst* inst = client->GetInv().GetItem(Legacy::SLOT_CURSOR);
 	if (!inst) {
 		client->Message(13, "Error: Could not find item on your cursor!");
 		return;
@@ -105,7 +105,7 @@ void Trade::AddEntity(uint16 from_slot_id, uint16 trade_slot_id)
 	}
 	else
 	{
-		if (client->GetInv().GetItem(SLOT_CURSOR)->GetID() != client->GetInv().GetItem(trade_slot_id)->GetID()) {
+		if (client->GetInv().GetItem(Legacy::SLOT_CURSOR)->GetID() != client->GetInv().GetItem(trade_slot_id)->GetID()) {
 			client->Kick();
 			return;
 		}
@@ -146,13 +146,13 @@ void Trade::SendItemData(const ItemInst* inst, int16 dest_slot_id)
 	Client* with = mob->CastToClient();
 	Client* trader = owner->CastToClient();
 	if (with && with->IsClient()) {
-		with->SendItemPacket(dest_slot_id -IDX_TRADE,inst,ItemPacketTradeView);
+		with->SendItemPacket(dest_slot_id -Legacy::IDX_TRADE,inst,ItemPacketTradeView);
 		if (inst->GetItem()->ItemClass == 1) {
 			for (uint16 i=0; i<10; i++) {
-				uint16 bagslot_id = Inventory::CalcSlotId(dest_slot_id, i);
+				uint16 bagslot_id = Legacy::CalcSlotId(dest_slot_id, i);
 				const ItemInst* bagitem = trader->GetInv().GetItem(bagslot_id);
 				if (bagitem) {
-					with->SendItemPacket(bagslot_id-IDX_TRADE,bagitem,ItemPacketTradeView);
+					with->SendItemPacket(bagslot_id-Legacy::IDX_TRADE,bagitem,ItemPacketTradeView);
 				}
 			}
 		}
@@ -318,7 +318,7 @@ void Client::ResetTrade() {
 		{
 			bool is_arrow = (TempItem->ItemType == ItemTypeArrow) ? true : false;
 			int freeslotid = GetInv().FindFreeSlot(ins->IsType(ItemClassContainer), true, TempItem->Size, is_arrow);
-			if (freeslotid == SLOT_INVALID)
+			if (freeslotid == Legacy::SLOT_INVALID)
 			{
 				DropInst(ins);
 			}
@@ -390,7 +390,7 @@ void Client::FinishTrade(Mob* tradingWith, ServerPacket* qspack, bool finalizer)
 
 							if(baginst == nullptr) { continue; }
 
-							int16 k=Inventory::CalcSlotId(i, j);
+							int16 k=Legacy::CalcSlotId(i, j);
 							item_count = qsaudit->char1_count + qsaudit->char2_count;
 
 							qsaudit->items[item_count].from_id		= this->character_id;
@@ -428,7 +428,7 @@ void Client::FinishTrade(Mob* tradingWith, ServerPacket* qspack, bool finalizer)
 									const ItemInst* bag_inst = inst->GetItem(bagslot_idx);
 
 									if(bag_inst == nullptr) { continue; }
-									int16 to_bagslot_id = Inventory::CalcSlotId(slot_id, bagslot_idx);
+									int16 to_bagslot_id = Legacy::CalcSlotId(slot_id, bagslot_idx);
 
 									qsaudit->items[++parent_offset].to_slot = to_bagslot_id;
 								}
@@ -441,14 +441,14 @@ void Client::FinishTrade(Mob* tradingWith, ServerPacket* qspack, bool finalizer)
 
 						if(QSPLT) {
 							qsaudit->items[parent_offset].to_id	= this->character_id;
-							qsaudit->items[parent_offset].to_slot = SLOT_CURSOR;
+							qsaudit->items[parent_offset].to_slot = Legacy::SLOT_CURSOR;
 
 							if(inst->IsType(ItemClassContainer)) {
 								for(uint8 bagslot_idx = 0; bagslot_idx < inst->GetItem()->BagSlots; bagslot_idx++) {
 									const ItemInst* bag_inst = inst->GetItem(bagslot_idx);
 
 									if(bag_inst == nullptr) { continue; }
-									int16 to_bagslot_id = Inventory::CalcSlotId(SLOT_CURSOR, bagslot_idx);
+									int16 to_bagslot_id = Legacy::CalcSlotId(Legacy::SLOT_CURSOR, bagslot_idx);
 
 									qsaudit->items[++parent_offset].to_id = this->character_id;
 									qsaudit->items[parent_offset].to_slot = to_bagslot_id;
@@ -465,14 +465,14 @@ void Client::FinishTrade(Mob* tradingWith, ServerPacket* qspack, bool finalizer)
 
 					if(QSPLT) {
 						qsaudit->items[parent_offset].to_id	= this->character_id;
-						qsaudit->items[parent_offset].to_slot = SLOT_CURSOR;
+						qsaudit->items[parent_offset].to_slot = Legacy::SLOT_CURSOR;
 
 						if(inst->IsType(ItemClassContainer)) {
 							for(uint8 bagslot_idx = 0; bagslot_idx < inst->GetItem()->BagSlots; bagslot_idx++) {
 								const ItemInst* bag_inst = inst->GetItem(bagslot_idx);
 
 								if(bag_inst == nullptr) { continue; }
-								int16 to_bagslot_id = Inventory::CalcSlotId(SLOT_CURSOR, bagslot_idx);
+								int16 to_bagslot_id = Legacy::CalcSlotId(Legacy::SLOT_CURSOR, bagslot_idx);
 
 								qsaudit->items[++parent_offset].to_id = this->character_id;
 								qsaudit->items[parent_offset].to_slot = to_bagslot_id;
@@ -553,7 +553,7 @@ void Client::FinishTrade(Mob* tradingWith, ServerPacket* qspack, bool finalizer)
 							if(trade_baginst) {
 								strcpy(qsaudit->items[qsaudit->char_count].action_type, "HANDIN");
 
-								qsaudit->items[qsaudit->char_count].char_slot	= Inventory::CalcSlotId(slot_id, bag_idx);
+								qsaudit->items[qsaudit->char_count].char_slot	= Legacy::CalcSlotId(slot_id, bag_idx);
 								qsaudit->items[qsaudit->char_count].item_id		= trade_baginst->GetID();
 								qsaudit->items[qsaudit->char_count].charges		= trade_baginst->GetCharges();
 								qsaudit->items[qsaudit->char_count].aug_1		= trade_baginst->GetAugmentItemID(1);
@@ -2214,7 +2214,7 @@ void Client::SellToBuyer(const EQApplicationPacket *app) {
 
 	if(!item || !Quantity || !Price || !QtyBuyerWants) return;
 
-	if(m_inv.HasItem(ItemID, Quantity, invWhereWorn|invWherePersonal|invWhereCursor) == SLOT_INVALID) {
+	if(m_inv.HasItem(ItemID, Quantity, invWhereWorn|invWherePersonal|invWhereCursor) == Legacy::SLOT_INVALID) {
 		Message(13, "You do not have %i %s on you.", Quantity, item->Name);
 		return;
 	}
@@ -2264,7 +2264,7 @@ void Client::SellToBuyer(const EQApplicationPacket *app) {
 			int16 SellerSlot = m_inv.HasItem(ItemID, 1, invWhereWorn|invWherePersonal|invWhereCursor);
 
 			// This shouldn't happen, as we already checked there was space in the Buyer's inventory
-			if(SellerSlot == SLOT_INVALID) {
+			if(SellerSlot == Legacy::SLOT_INVALID) {
 
 				if(i > 0) {
 					// Set the Quantity to the actual number we successfully transferred.
@@ -2316,7 +2316,7 @@ void Client::SellToBuyer(const EQApplicationPacket *app) {
 			// Find the slot on the seller that has a stack of at least 1 of the item
 			int16 SellerSlot = m_inv.HasItem(ItemID, 1, invWhereWorn|invWherePersonal|invWhereCursor);
 
-			if(SellerSlot == SLOT_INVALID) {
+			if(SellerSlot == Legacy::SLOT_INVALID) {
 				_log(TRADING__BARTER, "Unexpected error while moving item from seller to buyer.");
 				Message(13, "Internal error while processing transaction.");
 				return;
diff --git a/zone/zonedb.cpp b/zone/zonedb.cpp
index b95f866..0478b10 100644
--- a/zone/zonedb.cpp
+++ b/zone/zonedb.cpp
@@ -1951,7 +1951,7 @@ void ZoneDatabase::LoadMercEquipment(Merc *merc) {
 		int itemCount = 0;
 
 		while(DataRow = mysql_fetch_row(DatasetResult)) {
-			if(itemCount == MAX_WORN_INVENTORY)
+			if(itemCount == Legacy::MAX_WORN_INVENTORY)
 				break;
 
 			if(atoi(DataRow[0]) > 0) {
@@ -2780,7 +2780,7 @@ void ZoneDatabase::SavePetInfo(Client *c) {
 		}
 	}
 
-	for(i=0; i<MAX_WORN_INVENTORY; i++) {
+	for(i=0; i<Legacy::MAX_WORN_INVENTORY; i++) {
 		if(petinfo->Items[i]) {
 			database.RunQuery(query, MakeAnyLenString(&query,
 				"INSERT INTO `character_pet_inventory` (`char_id`, `pet`, `slot`, `item_id`) values (%u, 0, %u, %u)",
@@ -2804,7 +2804,7 @@ void ZoneDatabase::SavePetInfo(Client *c) {
 	}
 	safe_delete_array(query);
 
-	for(i=0; i<MAX_WORN_INVENTORY; i++) {
+	for(i=0; i<Legacy::MAX_WORN_INVENTORY; i++) {
 		if(suspended->Items[i]) {
 			database.RunQuery(query, MakeAnyLenString(&query,
 				"INSERT INTO `character_pet_inventory` (`char_id`, `pet`, `slot`, `item_id`) values (%u, 1, %u, %u)",
@@ -2937,7 +2937,7 @@ void ZoneDatabase::LoadPetInfo(Client *c) {
 				continue;
 
 			int slot = atoi(row[1]);
-			if (slot < 0 || slot > MAX_WORN_INVENTORY)
+			if (slot < 0 || slot > Legacy::MAX_WORN_INVENTORY)
 				continue;
 
 			pi->Items[slot] = atoul(row[2]);
diff --git a/zone/zonedb.h b/zone/zonedb.h
index 52700da..b8b1af7 100644
--- a/zone/zonedb.h
+++ b/zone/zonedb.h
@@ -73,7 +73,7 @@ struct PetInfo {
 	uint32	Mana;
 	float	size;
 	SpellBuff_Struct	Buffs[BUFF_COUNT];
-	uint32	Items[MAX_WORN_INVENTORY];
+	uint32	Items[Legacy::MAX_WORN_INVENTORY];
 	char	Name[64];
 };
 
